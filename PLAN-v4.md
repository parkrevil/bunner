# Card-centric Knowledge Base Design v4 (PostgreSQL Confirmed)

> **Scope**: Transition bunner-kb MCP server to Card-centric architecture  
> **Status**: Design v4.7 (8 contradiction/ambiguity fixes ‚Äî 2026-02-11)  
> **DB**: PostgreSQL (confirmed)  
> **Related code**: `tooling/mcp/`  
> **v4 is a self-contained document and does not depend on any prior design documents.**

---

## 1. Background and Motivation

### 1.1 Current Operational Model

| Category | Description | Registration Method |
|----------|-------------|---------------------|
| **Spec** | Feature specifications agreed upon by users and agents | Manual registration (`entity_type = 'spec'`) |
| **Code** | Modules/symbols extracted from TypeScript source files | Auto-generated by `sync` parser (`module:`, `symbol:` entities) |
| **Spec‚ÜîCode link** | Which code implements which spec | Manual link (`relation_type = 'implements'`, `strength = 'manual'`) |

### 1.2 Core Problem

The `entity_key` of code entities is **tied to file paths**. When a file is moved/renamed, the `entity.id` changes, causing **link breakage**.

The current `entity_key rewrite` + `grace window` approach:
- Identity preservation relies on a "correction mechanism" (patching, not declaration)
- 7 types of grace window edge cases, pending_delete, and other incidental complexity
- No governance, no contract history

### 1.3 Limitations of Prior Designs (Why v4 Is Needed)

The identity/version separation solved the file-path dependency problem. However, prior designs had the following limitations:

| Limitation | Description |
|------------|-------------|
| **Code-centric** | KB centers on code; specs are secondary. Core question: "What is this code's structure?" |
| **Spec/Claim dual structure** | Specs and sub-items managed as separate entity_types. No nesting (depth fixed at 1) |
| **Flat coverage** | Simple `linked / total` ratio. No weights or priorities |
| **Single relation table** | code‚Üîcode static analysis and spec‚Üîcode manual links coexist in the same table |
| **Single evidence type** | Only fact references. No polymorphism for test, annotation, review, etc. |
| **No spec attributes** | No status, priority, tags, or weight. Insufficient classification/filtering |
| **Numerous design bugs** | DDL bugs, SQL errors, and spec omissions identified during review |

### 1.4 v4 Design Goals

Building on prior design's identity/version separation + 3-tier defense + approval_event governance:

1. **Card-centric KB**: Shift central axis from code ‚Üí card. Card = first-class knowledge object
2. **Unified card model**: Abolish spec/claim dual structure ‚Üí single nested card tree model
3. **Separate connection models**: card_link / card_relation / code_relation (3 types)
4. **Evidence polymorphism**: code_link, test_pass, annotation, manual_review, ai_verification
5. **Card lifecycle**: draft ‚Üí accepted ‚Üí implementing ‚Üí verified ‚Üí deprecated + downward propagation
6. **Composite coverage**: Recursive weighted aggregation + cross-tag aggregation
7. **Card attribute normalization**: status/priority/tags/weight promoted to dedicated columns (avoid JSONB overuse)
8. **Multi-tenancy/multi-project/branch**: tenant > project > workspace(branch) + user
9. **Deployment model**: N MCP(local) : 1 DB(shared). workspace/user = label principle, Git-independent principle (v4.3)
10. **Graph Read Model (data preparation only)**: Schema/index/query patterns enabling subgraph queries without creating VIEWs/TABLEs
11. **Search/vector readiness**: Postgres FTS + pgvector hooks
12. **Agent Context Retrieval**: Tools for agents to quickly obtain minimal context
13. **Incorporate all DDL/SQL/spec bugs identified in prior design reviews**

### 1.5 DB Choice: PostgreSQL Confirmed

**Decision summary**: bunner-kb is primarily a local development tool (MCP server), and v4's core lies in governance/integrity (approval_event, identity/version, link/evidence), so PostgreSQL is confirmed as SSOT.

**Rationale**

- **Referential integrity**: Declarative guarantee at DB level via FK + `ON DELETE CASCADE/SET NULL/RESTRICT`
- **Transaction safety**: Advantageous for tightly binding approval_event + version + link/evidence in a single transaction
- **Self-hosting**: Core features including FTS/pgvector operable without cloud dependency
- **Current stack fit**: `tooling/mcp/` is built around Drizzle ORM + PostgreSQL

---

## 2. Design Principles

### 2.1 Card-first

> The central axis of the KB is the card. Code is evidence that implements a card.

Shift in the core question:
- Before: "What is this code's structure?"
- **v4: "What is the implementation status of this requirement?"**

A card is not a mere document but a **first-class knowledge object**. It has a stable ID, is version-managed, and its state is tracked via a lifecycle state machine.

### 2.2 Evidence-typed

Code is **evidence** of card fulfillment. There are multiple evidence types:

| Evidence Type | Description | Collection Method |
|---------------|-------------|-------------------|
| `code_link` | Code entity is linked | Manual (link_card) |
| `test_pass` | Test passed | Automatic (CI integration) |
| `annotation` | `@card` annotation exists in code | Automatic (parser) |
| `manual_review` | Confirmed by a human | Manual |
| `ai_verification` | AI confirmed code‚Üîcard alignment | Automatic |

### 2.3 Human-approved Truth

The system's truth is based on **approval logs**, not inference.

- **Automatic**: Only deterministic cases (identical content_hash, 1:1 match)
- **Semi-automatic**: Only present candidates and rationale
- **Manual confirmation**: Final link/identity confirmation requires an approval event

### 2.4 Evaluation Criteria

| Criterion | Definition | v4 Goal |
|-----------|------------|---------|
| **Auditability** | Can we reproduce why this link was created? | Full reproduction via approval_event + evidence + anchor |
| **Reversibility** | Can false positives be safely reverted? | Rollback via compensating approval_event |
| **Governance** | Is the boundary between automation and human responsibility clear? | Card lifecycle + approval events as single source of truth |
| **Evolution cost** | Does rule complexity stay sub-linear as scale grows? | identity+version + nested card tree |
| **Discoverability** | Can desired information be found easily? | Filtering by tag + priority + status |

### 2.5 Portability Principle

bunner-kb is a **vibe-coding RAG server** agnostic to language/project/environment.

| Principle | Practice |
|-----------|----------|
| Do not mix core and parsers | Do not embed language-specific parser code in identity/version/card/approval logic |
| Do not assume entity_key format in core | Core treats entity_key as an opaque string |
| Finalize the parser interface | Explicitly define the `KBParser` interface |
| Centralize config | Externalize file extensions, hash granularity, @card patterns, etc. to a config file |

#### KBParser Interface

```typescript
interface KBParser {
  /** Supported file extensions */
  extensions: string[];
  /** Parse a file to extract entities/facts/relations */
  parseFile(filePath: string, content: string): ParseResult;
  /** Compute content_hash (normalization rules specified) */
  computeHash(content: string): string;
}

interface ParseResult {
  entities: ParsedEntity[];
  facts: ParsedFact[];
  relations: ParsedRelation[];
}
```

> **content_hash computation rules**: SHA-256 after UTF-8 normalization. Remove BOM, strip trailing whitespace, normalize to LF before hashing. Specified in the `computeHash` implementation.

### 2.6 KB Scope Policy (Scope Boundary)

Decision criterion: "If this knowledge changes, **does specific code need to be modified?**"

| Knowledge Type | Coupling to Code | Management Location |
|----------------|-----------------|---------------------|
| **Card (requirements)** | üî¥ Strong | **KB** (entity) |
| Project philosophy/vision | ‚ö™ None | **Documentation** |
| Architecture decisions (ADR) | üü° Weak | **Documentation** |
| Style guide | üü° Weak | **Documentation + linter** |
| Agent rules | ‚ö™ None | **Documentation** (AGENTS.md) |

### 2.7 Multi-tenancy/Project/Branch Model

v4 expands beyond the single-workspace assumption, establishing the following hierarchy as SSOT:

- **tenant**: Organization/user boundary (deployment unit)
- **project**: Card knowledge boundary (requirements SSOT)
- **workspace**: Code indexing unit = **project + branch**
- **user**: Actor identification (v4.3 B-1)

#### Design Principles (v4.3 E-1, E-2, E-3)

1. **workspace/user = label principle**: workspace and user serve only as **labels** that categorize data. Data must not depend on them. DB data must be guaranteed regardless of any branch/user pattern.
2. **Git-independent principle**: The DB is independent of Git. It does not depend on Git hooks. Whether a branch is merged, abandoned, or deleted, DB data is unaffected.
3. **project_id retention rationale**: In a single-project environment, `project_id` is fixed to `'default'`. It has no functional role, but is retained for multi-project expansion. Removal cost (34 references across all tables/indexes/RLS) > maintenance cost (1 TEXT column).

#### Scope Rules (Core)

- **Card / Card relations (`card_relation`)**: **project scope**
- **Code / Code relations (`code_relation`)**: **workspace scope**
- **Card‚ÜîCode connections (`card_link`)**: **cross-scope** (project's card ‚Üî workspace's code)
- **Approval Event**: Defaults to **project scope**; `workspace_id` recorded as supplementary when needed

#### Minimal Schema (Conceptual)

```sql
CREATE TABLE tenant (
  id         TEXT PRIMARY KEY,
  name       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE "user" (
  id         TEXT PRIMARY KEY,
  email      TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE project (
  id         TEXT PRIMARY KEY,
  tenant_id  TEXT NOT NULL REFERENCES tenant(id),
  name       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE workspace (
  id          TEXT PRIMARY KEY,
  project_id  TEXT NOT NULL REFERENCES project(id),
  branch_name TEXT NOT NULL,
  root_path   TEXT,
  status      TEXT NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'archived')),
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Unique branch_name only for active workspaces (v4.3 A-2)
CREATE UNIQUE INDEX workspace_project_branch_unique
  ON workspace(project_id, branch_name)
  WHERE status = 'active';
```

> In a single-user/single-project environment, you can fix `tenant = 'default'`, `project = repo`, `workspace = branch`.

> **`"user"` table** (v4.3 B-1): A minimal table for actor (user) identification. `user` is a PostgreSQL reserved word, so it is quoted as `"user"`. In Drizzle ORM, table name mapping allows referencing it as `user` in code. Future auth/management systems can extend this table.

> **TEXT PK generation strategy** (v4.5 L-2): `tenant.id`, `project.id`, `workspace.id`, `"user".id` are all `TEXT PRIMARY KEY`. Generation strategies:
> - `workspace.id`: **ULID** (`01HXYZ...`) recommended. Time-sortable + collision-free unique value. Use `Bun.randomUUIDv7()` or the `ulid()` library.
> - `tenant.id`, `project.id`: User-specified slug (`'default'`, `'my-project'`). Fixed value in single environments.
> - `"user".id`: User-specified identifier (e.g., `'alice'`, `'bob'`). Can be replaced with an external ID when integrating a future auth system.

> **workspace append-only principle** (v4.3 A-5): Workspaces are **only created, never deleted.** Same philosophy as entity_identity. Deactivation is handled via `status = 'archived'`. A new workspace is created each time for the same `branch_name` (id is always a new unique value). It is a separate record from any previously archived workspace with the same branch_name. Reason: Even branches with the same name represent completely different code states at different points in time, preventing old data contamination (v4.3 A-3).

#### Deployment Topology (v4.3 D-1)

Recommended deployment model: **N MCP(each local) : 1 DB(shared)**

```
[Alice PC]  Cursor IDE ‚Üî Local MCP server ‚Üí Shared PostgreSQL
[Bob PC]    Cursor IDE ‚Üî Local MCP server ‚Üí Shared PostgreSQL
[Server]    PostgreSQL (team-shared)
```

- Each developer runs an MCP server on their PC (Cursor ‚Üî MCP via stdio/local HTTP)
- Only the DB is team-shared (1 PostgreSQL server)
- Sync Worker indexes local code on each machine ‚Üí stored in DB differentiated by `workspace_id`
- Cards are naturally team-shared via DB (project scope)
- Only `DATABASE_URL` needs to point to the shared PostgreSQL

> **MCP server config required settings** (v4.3 D-3): Each MCP instance must set `user_id` (‚Üí references `"user".id`). All write operations automatically record this `user_id` as `actor_id`.
>
> **Behavior when user_id is not set** (v4.4 P-5): If `user_id` is absent from config, the MCP server **raises an error at startup** and exits (`"BUNNER_USER_ID is required"`). If the corresponding id does not exist in the `"user"` table, an error is raised on the first write (`"User not found: {user_id}"`). Auto-creation is not performed ‚Äî user registration is handled via a separate administrative procedure (seed or management tool).

> **Concurrent sync defense** (v4.3 D-2): If two users run sync simultaneously on the same workspace, conflicts may occur. Serialization is enforced via `pg_advisory_xact_lock(hashtext(workspace_id))` at `sync_run` start. Can transition to fine-grained per-file locking in v3.1.

#### Archived Workspace Query Exclusion Pattern (v4.4 P-4)

All workspace-scoped queries must exclude archived data. Two patterns:

```sql
-- Pattern 1: Direct workspace_id filter (most tools ‚Äî explicit workspaceId input)
WHERE ev.workspace_id = :workspace_id  -- Caller guarantees workspace_id is active

-- Pattern 2: Workspace listing queries (dashboard, management tools)
SELECT * FROM workspace WHERE project_id = :project_id AND status = 'active'
```

> **Rule**: MCP tools validate the `status` of the input `workspaceId`. Write attempts to an archived workspace return an error (`"Workspace is archived"`). Reads are permitted for history inquiry purposes, but the tool response must include an `archived: true` flag.

#### RLS (Row-Level Security) Direction

Multi-tenancy isolation is enforced via PostgreSQL RLS. Within v4 scope, only the policy design is specified; implementation proceeds in v3.1.

```sql
-- Example: RLS on entity_version based on project
ALTER TABLE entity_version ENABLE ROW LEVEL SECURITY;
CREATE POLICY entity_version_project_isolation ON entity_version
  USING (project_id = current_setting('app.current_project_id')::text);
```

| Target | Isolation Basis | Notes |
|--------|----------------|-------|
| Card-related tables | `project_id` | card, card_relation, approval_event |
| Code-related tables | `workspace_id` | code_relation, entity_version(code) |
| Cross-scope tables | `project_id` + `workspace_id` | card_link |

> **v4 scope**: RLS policy definition. **v3.1**: `SET app.current_project_id` injection mechanism + Drizzle ORM integration.

---

## 3. Identity Model

> The identity/version separation is the core foundation of v4. The principles and schema below permeate all of v4.

### 3.1 Core Principles

> **`entity_identity.id` is the true identity. This ID is immutable throughout the entity's entire lifetime.**
>
> `entity_key` is the address (version) at a specific point in time; when a file moves, a new version is added.
> card_link references `entity_identity.id` as an FK, so **links are preserved regardless of path changes.**

### 3.2 Identity Definition by Level

| Level | Identity (immutable) | Address (mutable) | Matching Signal |
|-------|---------------------|-------------------|-----------------|
| **Module** | `entity_identity.id` | `module:{file_path}` ‚Üí `entity_version` | `content_hash` (SHA-256) |
| **Symbol** | `entity_identity.id` | `symbol:{file_path}#{symbol_name}` ‚Üí `entity_version` | Parent module's identity + `symbol_name` |
| **Card** | `entity_identity.id` | `card::{path}` ‚Üí `entity_version` | User-defined `stable_key` (immutable, project scope) |

> **Difference from prior design**: The two types `spec` and `claim` are unified into a single `card`. Instead of `spec::`/`claim::` prefixes, a single `card::` prefix is used.

### 3.3 Identity + Version Schema

#### Reference Tables (`entity_type`, `sync_run`)

Base tables referenced by `entity_identity` and `entity_version`:

```sql
CREATE TABLE entity_type (
  id   SMALLSERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE   -- 'module', 'symbol', 'card'
);

CREATE TABLE sync_run (
  id          SERIAL PRIMARY KEY,
  workspace_id TEXT NOT NULL REFERENCES workspace(id),
  run_type    TEXT NOT NULL CHECK (run_type IN ('startup', 'watch', 'manual')),
  started_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  finished_at TIMESTAMPTZ,
  files_scanned INTEGER,
  entities_created INTEGER,
  entities_updated INTEGER,
  entities_archived INTEGER,
  meta        JSONB NOT NULL DEFAULT '{}'::jsonb
);
```

#### `entity_identity` (Identity ‚Äî immutable)

```sql
CREATE TABLE entity_identity (
  id            SERIAL PRIMARY KEY,
  project_id    TEXT NOT NULL REFERENCES project(id),
  workspace_id  TEXT REFERENCES workspace(id),
  entity_type_id SMALLINT NOT NULL REFERENCES entity_type(id),
  stable_key    TEXT,          -- Only card entities have a value. Code entities are NULL
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Only when stable_key is present (card entity). Cards are project-scoped, so unique on project_id
CREATE UNIQUE INDEX idx_identity_card_stable_key
  ON entity_identity(project_id, stable_key)
  WHERE stable_key IS NOT NULL;

-- Code entities are workspace-scoped, so optimize lookups by workspace_id
CREATE INDEX idx_identity_workspace_type
  ON entity_identity(workspace_id, entity_type_id)
  WHERE workspace_id IS NOT NULL;
```

> **project_id ‚Üî workspace.project_id consistency** (v4.2 A-2): For code entities (`workspace_id IS NOT NULL`), `project_id` must always match the workspace's `project_id`. Enforced via DB trigger:
> ```sql
> CREATE OR REPLACE FUNCTION enforce_identity_project_consistency() RETURNS trigger AS $$
> BEGIN
>   IF NEW.workspace_id IS NOT NULL THEN
>     IF NEW.project_id != (SELECT project_id FROM workspace WHERE id = NEW.workspace_id) THEN
>       RAISE EXCEPTION 'entity_identity.project_id must match workspace.project_id';
>     END IF;
>   END IF;
>   RETURN NEW;
> END;
> $$ LANGUAGE plpgsql;
>
> CREATE TRIGGER trg_identity_project_consistency
>   BEFORE INSERT OR UPDATE ON entity_identity
>   FOR EACH ROW EXECUTE FUNCTION enforce_identity_project_consistency();
> ```

> **stable_key immutability**: Once set, `stable_key` cannot be changed. Enforced via DB trigger:
> ```sql
> CREATE OR REPLACE FUNCTION prevent_stable_key_update() RETURNS trigger AS $$
> BEGIN
>   IF OLD.stable_key IS NOT NULL AND NEW.stable_key IS DISTINCT FROM OLD.stable_key THEN
>     RAISE EXCEPTION 'stable_key is immutable once set';
>   END IF;
>   RETURN NEW;
> END;
> $$ LANGUAGE plpgsql;
>
> CREATE TRIGGER trg_stable_key_immutable
>   BEFORE UPDATE ON entity_identity
>   FOR EACH ROW EXECUTE FUNCTION prevent_stable_key_update();
> ```

#### `entity_version` (Version ‚Äî mutable address/state)

```sql
CREATE TABLE entity_version (
  id            SERIAL PRIMARY KEY,
  identity_id   INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  project_id    TEXT NOT NULL REFERENCES project(id),
  workspace_id  TEXT REFERENCES workspace(id),
  entity_key    TEXT NOT NULL,
  summary       TEXT,

  -- Card normalized columns (project scope)
  card_status        TEXT,
  card_priority      TEXT,
  card_tags          TEXT[] NOT NULL DEFAULT '{}',
  card_weight        REAL,
  card_template_type TEXT,
  card_body          TEXT,
  card_external_refs JSONB NOT NULL DEFAULT '[]'::jsonb,
  card_acceptance_criteria JSONB NOT NULL DEFAULT '[]'::jsonb,

  meta          JSONB NOT NULL DEFAULT '{}'::jsonb,
  content_hash  TEXT,
  status        TEXT NOT NULL DEFAULT 'active'
    CHECK (status IN ('active', 'archived', 'superseded')),
  version_num   INTEGER NOT NULL DEFAULT 1,
  last_seen_run INTEGER REFERENCES sync_run(id),
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- card(active) unique: project scope (workspace_id IS NULL)
CREATE UNIQUE INDEX version_active_unique_project
  ON entity_version(project_id, entity_key)
  WHERE status = 'active' AND workspace_id IS NULL;

-- code(active) unique: workspace scope
CREATE UNIQUE INDEX version_active_unique_workspace
  ON entity_version(workspace_id, entity_key)
  WHERE status = 'active' AND workspace_id IS NOT NULL;

-- Card column constraints (NULL allowed for code entities)
ALTER TABLE entity_version
  ADD CONSTRAINT card_weight_range
  CHECK (card_weight IS NULL OR (card_weight >= 0.0 AND card_weight <= 1.0));

ALTER TABLE entity_version
  ADD CONSTRAINT card_priority_enum
  CHECK (card_priority IS NULL OR card_priority IN ('P0', 'P1', 'P2', 'P3'));

ALTER TABLE entity_version
  ADD CONSTRAINT card_status_enum
  CHECK (card_status IS NULL OR card_status IN ('draft', 'proposed', 'accepted', 'implementing', 'implemented', 'verified', 'deprecated'));

-- GIN index for card_tags filtering/aggregation (v4.2 D-3)
CREATE INDEX entity_version_card_tags_gin_idx
  ON entity_version USING GIN (card_tags)
  WHERE card_tags != '{}';

-- FTS ranking (v4.5 H-1, v4.7 F-1):
-- search_tsv is a tsvector for weighted ranking of entity_key/summary/card_body.
-- Role: Sort results via ts_rank() (English/entity_key exact matching + weights)
-- Korean partial matching is handled by the pg_bigm index (see ¬ß14.6, ¬ß14.7).
-- Relationship between the two indexes: pg_bigm = Korean LIKE search ‚Üí candidate filtering,
--                  search_tsv = ts_rank() ‚Üí candidate ranking.
-- In environments without pg_bigm, search_tsv alone serves as fallback (accepting degraded Korean quality).
ALTER TABLE entity_version ADD COLUMN search_tsv TSVECTOR;

CREATE INDEX entity_version_search_tsv_idx
  ON entity_version USING GIN (search_tsv)
  WHERE search_tsv IS NOT NULL;

-- Trigger for automatic search_tsv update
CREATE OR REPLACE FUNCTION update_entity_version_search_tsv() RETURNS trigger AS $$
BEGIN
  NEW.search_tsv :=
    setweight(to_tsvector('simple', COALESCE(NEW.entity_key, '')), 'A') ||
    setweight(to_tsvector('simple', COALESCE(NEW.summary, '')), 'B') ||
    setweight(to_tsvector('simple', COALESCE(NEW.card_body, '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_entity_version_search_tsv
  BEFORE INSERT OR UPDATE OF entity_key, summary, card_body ON entity_version
  FOR EACH ROW EXECUTE FUNCTION update_entity_version_search_tsv();
```

> **entity_version.project_id ‚Üî entity_identity.project_id consistency** (v4.5 I-1): entity_version's project_id must always match its identity's project_id. Guaranteed at the app level, with a defensive trigger also installed:
> ```sql
> CREATE OR REPLACE FUNCTION enforce_version_project_consistency() RETURNS trigger AS $$
> BEGIN
>   IF NEW.project_id != (SELECT project_id FROM entity_identity WHERE id = NEW.identity_id) THEN
>     RAISE EXCEPTION 'entity_version.project_id must match entity_identity.project_id';
>   END IF;
>   RETURN NEW;
> END;
> $$ LANGUAGE plpgsql;
>
> CREATE TRIGGER trg_version_project_consistency
>   BEFORE INSERT OR UPDATE ON entity_version
>   FOR EACH ROW EXECUTE FUNCTION enforce_version_project_consistency();
> ```

> **Column naming convention** (v4.2 E-1): `entity_version` has both `status` and `card_status` columns. To avoid confusion, the following convention is used:
> - `status` = **version lifecycle** ('active'/'archived'/'superseded'). Referenced as `versionStatus` in code
> - `card_status` = **card lifecycle** ('draft'/'proposed'/...). Referenced as `cardStatus` in code
> - When both are used in a SQL query, always alias as `ev.status AS version_status, ev.card_status`

| Column | Description |
|--------|-------------|
| `status` | Version lifecycle. `'active'` = currently valid, `'archived'` = deactivated due to path change, `'superseded'` = used during identity merge/replacement |

> **`superseded` transition condition**: When relations are transferred to another identity via `apply_identity_rewrite`, the original identity's version transitions to `superseded`. Transition condition: "all manual relations of that identity have been transferred to another identity".

#### `entity_lifecycle` (Lifecycle Event Log)

```sql
CREATE TABLE entity_lifecycle (
  id            SERIAL PRIMARY KEY,
  identity_id   INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  event_type    TEXT NOT NULL
    CHECK (event_type IN ('created', 'updated', 'renamed', 'split', 'merged',
                          'superseded', 'archived', 'restored',
                          'status_changed', 'reparented')),
    -- v4 additions: status_changed (card lifecycle), reparented (card move)
  from_version_id INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  to_version_id   INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  related_identity_id INTEGER REFERENCES entity_identity(id),
  meta          JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

> `ON DELETE SET NULL` is set on `from_version_id` and `to_version_id` to prevent FK violations during version purge.

#### `source` (File Origin ‚Äî dependent on version)

```sql
CREATE TABLE source (
  id          SERIAL PRIMARY KEY,
  version_id  INTEGER NOT NULL REFERENCES entity_version(id) ON DELETE CASCADE,
  kind        TEXT NOT NULL CHECK (kind IN ('file', 'card', 'manual')),
  file_path   TEXT,                -- file: actual path, card: "__manual__/card/{cardKey}"
  file_hash   TEXT,
  meta        JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX source_version_idx ON source(version_id);
CREATE INDEX source_file_path_idx ON source(file_path);
```

#### `fact_type`, `strength_type`, `fact` (Parsed Results Storage)

```sql
CREATE TABLE fact_type (
  id   SMALLSERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE      -- 'module_info', 'symbol_info', 'card_body', ...
);

CREATE TABLE strength_type (
  id   SMALLSERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE      -- 'inferred', 'manual', 'derived'
);

CREATE TABLE fact (
  id              SERIAL PRIMARY KEY,
  version_id      INTEGER NOT NULL REFERENCES entity_version(id) ON DELETE CASCADE,
  fact_type_id    SMALLINT NOT NULL REFERENCES fact_type(id),
  fact_key        TEXT NOT NULL,
  payload         JSONB NOT NULL DEFAULT '{}'::jsonb,
  payload_text    TEXT,            -- Text subject to FTS, e.g. card_body
  strength_id     SMALLINT NOT NULL REFERENCES strength_type(id),
  meta            JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX fact_version_idx ON fact(version_id);
CREATE INDEX fact_type_key_idx ON fact(fact_type_id, fact_key);
```

> **source/fact lifecycle**: Both reference `entity_version(id)` as FK, and are automatically cleaned up when a version is CASCADE deleted. `card_evidence.fact_id` uses `ON DELETE SET NULL`, so evidence records are preserved even when a fact is deleted (snapshots are stored in the snapshot field).

### 3.4 Identity Lookup Strategy

4-level priority:

```
1. stable_key   ‚Äî When NOT NULL (card entity). WHERE project_id = :project AND stable_key = :key
2. entity_key   ‚Äî Lookup by active version's entity_key (branching by project/workspace scope)
3. identity.id  ‚Äî Direct ID specification (for internal tools)
4. content_hash ‚Äî For identity matching
```

```typescript
type IdentityLookup =
  | { by: 'stableKey'; stableKey: string; projectId: string }
  | { by: 'projectEntityKey'; entityKey: string; projectId: string }
  | { by: 'workspaceEntityKey'; entityKey: string; workspaceId: string }
  | { by: 'identityId'; identityId: number }
  | { by: 'contentHash'; contentHash: string; workspaceId: string; entityTypeId?: number };
```

---

## 4. Card Model (Unified Nested Card)

### 4.1 Core Transition: spec/claim ‚Üí card

The prior design's dual spec/claim structure is unified into a **single card model**.

| | Prior | v4 |
|---|---|---|
| entity_type | `spec`, `claim` (2 types) | **`card`** (1 type) |
| Hierarchy | spec ‚Üí claim (fixed depth=1) | **card nested tree** (unlimited depth) |
| prefix | `spec::`, `claim::` | **`card::`** |
| parent | Only claim requires parentSpecKey, spec cannot | **All cards have parent_card_id** (root is NULL) |

### 4.2 Card Key Format

```
card::{path}

Examples:
  card::auth                        (root card)
  card::auth/login                  (child)
  card::auth/login/oauth            (grandchild)
  card::auth/login/oauth/google     (great-grandchild)
```

Validation regex: `/^card::([a-z0-9][a-z0-9-]*[a-z0-9])(\/[a-z0-9][a-z0-9-]*[a-z0-9])*$/`

- Each path segment is kebab-case (minimum 2 characters)
- `/` separates hierarchy levels
- The path reflects tree structure, but **the actual parent-child relationship is the `contains` relation in `card_relation` as the SSOT**

> **card_key path vs actual tree mismatch policy** (v4.2 B-1):
> Since `stable_key` is immutable, even when a card is moved to a different parent via `move_card`, the card_key path does not change. Example: Moving `card::auth/login` to become a child of `billing` ‚Äî the key remains `card::auth/login` but the actual parent is `billing`.
>
> **Rules**:
> - card_key path is **merely a hint reflecting the intent at initial registration**
> - The actual tree structure **must always be determined by querying `card_relation(contains)`**
> - When returning card information in tool responses, include an `actualParentKey` field to make any mismatch explicit
> - Consumer tools such as `get_context`, `get_implementation_guide` etc. construct the tree based on card_relation, not card_key path

### 4.3 Card Attribute Extensions

In v4, **core card attributes frequently used for search/filter/aggregation** are **promoted to dedicated columns** in `entity_version`. (Prevents JSONB overuse)

- Dedicated columns: `card_status`, `card_priority`, `card_tags`, `card_weight`, `card_template_type`, `card_body`
- Remain in JSONB: `card_external_refs`, `card_acceptance_criteria`, other extension metadata (`meta`)

```typescript
interface CardRecord {
  body: string;
  status: CardStatus;
  priority: CardPriority | null;
  tags: string[];
  weight: number;
  templateType: CardTemplateType | null;
  externalRefs: ExternalRef[];
  acceptanceCriteria: AcceptanceCriterion[];
}

type CardStatus = 'draft' | 'proposed' | 'accepted' | 'implementing' | 'implemented' | 'verified' | 'deprecated';
type CardPriority = 'P0' | 'P1' | 'P2' | 'P3';
type CardTemplateType = 'feature' | 'bug' | 'integration' | 'constraint' | 'custom';

interface ExternalRef {
  type: 'jira' | 'github_issue' | 'figma' | 'url';
  url: string;
  label?: string;
}

interface AcceptanceCriterion {
  given: string;
  when: string;
  then: string;
}
```

> `CardRecord` is the API-facing model; storage is decomposed into `entity_version` columns + partial JSONB.

### 4.4 Card Lifecycle State Machine

```
draft ‚îÄ‚îÄpropose‚îÄ‚îÄ‚Üí proposed ‚îÄ‚îÄaccept‚îÄ‚îÄ‚Üí accepted ‚îÄ‚îÄstart‚îÄ‚îÄ‚Üí implementing
                                                              ‚îÇ
                  deprecated ‚Üê‚îÄ‚îÄdeprecate‚îÄ‚îÄ verified ‚Üê‚îÄ‚îÄverify‚îÄ‚îÄ implemented
```

#### State Definitions

| State | Meaning | Entry Condition |
|------|------|----------|
| `draft` | Draft. Still under discussion | Default creation state |
| `proposed` | Review requested | Transition from draft |
| `accepted` | Approved. Awaiting implementation | Transition from proposed (approval required) |
| `implementing` | Implementation in progress | Transition from accepted |
| `implemented` | Implementation complete. Awaiting verification | Transition from implementing |
| `verified` | Verification complete | Transition from implemented (evidence conditions met ‚Äî see below) |
| `deprecated` | Deprecated. No longer valid | Can transition from any state |

#### State Transition Rules

```typescript
const CARD_STATUS_TRANSITIONS: Record<CardStatus, CardStatus[]> = {
  draft:        ['proposed', 'deprecated'],
  proposed:     ['accepted', 'draft', 'deprecated'],
  accepted:     ['implementing', 'proposed', 'deprecated'],
  implementing: ['implemented', 'accepted', 'deprecated'],
  implemented:  ['verified', 'implementing', 'deprecated'],
  verified:     ['deprecated'],
  deprecated:   [],  // terminal state (restoration only via rollback)
};
```

#### Downward Propagation Policy

| Parent state transition | Effect on children | Method |
|-----------------|------------------|------|
| ‚Üí `deprecated` | All children also `deprecated` + associated card_link set to `stale_status = 'stale_confirmed'` | **Forced propagation** (recursive). Individual `card_status_changed` event generated per child (v4.2 D-5) |
| ‚Üí `draft` (rollback) | No effect | Child states preserved |
| Other transitions | **Upper-bound warning** (soft): If a child's state exceeds the parent's, a warning is returned but not blocked | Example: If parent is `accepted` but child is `verified`, a warning is issued |

> **Upper-bound constraint ‚Üí upper-bound warning** (v4.2 F-2): The v4.1 "upper-bound constraint" was a hard block, but in vibe-coding it is natural for agents to complete implementation bottom-up starting from leaf cards. Therefore the upper bound is relaxed to a **warning**. The `update_card_status` response includes `warnings: string[]` returning a "child exceeds parent status" warning, but the transition itself is allowed.

> **Upper-bound ordering** (warning criteria): `draft < proposed < accepted < implementing < implemented < verified`

#### card_link Stale Marking on deprecated Transition (v4.2 D-1)

When a card transitions to `deprecated` in `update_card_status`:
1. All `card_link`s of that card are updated to `stale_status = 'stale_confirmed'`
2. card_links of propagated child cards are handled identically
3. `inconsistency_report` includes stale links of deprecated cards

> **card_links are NOT deleted**: deprecated means "retired", not "deleted". Links are preserved but marked as stale, allowing explicit cleanup via `unlink_card` or migration to another card (`unlink` ‚Üí `link_card`) when needed.

#### verified Transition Evidence Condition (v4.2 C-1)

The following conditions are verified during `implemented ‚Üí verified` transition:

| Condition | Rule | Enforcement Level |
|------|------|----------|
| Active evidence exists | At least 1 evidence with `is_active=true` exists among the card's card_links | **Required** (transition rejected if not met) |
| acceptance_criteria matching | If card.acceptance_criteria exists, corresponding evidence/links must exist for all items | **Warning** (warning returned if not met, transition allowed) |

> Leaf cards (no children) require card_link + evidence directly, while parent cards can transition to verified without evidence if all children are verified (composite coverage = 100%).

#### approval_event Integration

All state transitions create an `approval_event`:
- `event_type: 'card_status_changed'`
- `payload: { cardKey, fromStatus, toStatus, propagatedChildren: [...] }`
- **On deprecated propagation**: parent event + **individual `card_status_changed` event per child** generated (v4.2 D-5). Each child event's `parent_event_id` references the parent's event id. This enables **individual rollback per child**.

#### Relationship Between status Changes and Versions (v4.2 B-2)

> **Design decision**: `card_status` changes are **in-place updates** on the existing active version and do not create a new version (version_num unchanged). Reasons:
> - A status change is not a change to the card's **content (body)** but a **workflow state** change
> - Creating a new version for every status-only change would cause version explosion
> - Status change history is recorded in `entity_lifecycle(event_type: 'status_changed')` + `approval_event(card_status_changed)`
>
> **Impact on stale detection**: version_num comparison-based stale detection only responds to body changes and does not respond to status changes. This is intentional ‚Äî status changes are unrelated to "whether the code implements the card", so there's no reason to mark links as stale. However, `deprecated` transitions are handled separately in ¬ß4.4 "card_link stale marking on deprecated transition".

### 4.5 Card Body Recommended Format

A **recommended convention**, not enforced. Free-form markdown is also allowed.

```markdown
## Requirements
{What this card requires in 1-3 sentences}

## Acceptance Criteria
- Given: {precondition}
- When: {action}
- Then: {expected result}

## Notes (optional)
{Additional context, related card references, etc.}
```

### 4.6 Structural Versioning (v3.1-based design)

**Structural changes** (reparent, reorder) to the card tree must be distinguished from content changes.

| Change Type | Recorded In | Example |
|----------|----------|------|
| Content change | `entity_version` (new version added) | card body edit |
| Structural change | `entity_lifecycle` (`event_type: 'reparented'`) + `card_relation` update | Card move |

> **v4 scope**: Recorded as `reparented` event in `entity_lifecycle`. Full tree snapshot is v3.1.

---

## 5. Connection Model

### 5.1 Three-Way Separation

In the prior design, all relationships were in a single `relation` table. In v4, they are separated into 3 types by nature.

| Table | Subjects | Unique Attributes | Creation Method |
|--------|------|----------|----------|
| **`card_link`** | card ‚Üî code | anchor, rationale, stale_status, verified_at | Manual / @card auto |
| **`card_relation`** | card ‚Üî card | contains, depends_on, extends, cycle check | Manual |
| **`code_relation`** | code ‚Üî code | import, extends, calls | Parser auto |

#### Rationale for Separation

- Attributes only needed for **card_link**: `anchor`, `rationale`, `stale_status`, `verified_at`, `evidence[]`
- **code_relation** does not need governance overhead (approval_event, manual deletion prohibition, etc.)
- Query simplification: `SELECT * FROM card_link WHERE stale_status = 'stale'`

#### relation_type_registry (Relation Type Extension)

Hardcoding `card_relation`/`code_relation`'s `relation_type` with `CHECK (IN ...)` has high extension cost.
In v4, relation types are managed in a registry table and referenced via FK.

```sql
CREATE TABLE relation_type_registry (
  id          SMALLSERIAL PRIMARY KEY,
  domain      TEXT NOT NULL CHECK (domain IN ('card_relation', 'code_relation')),
  key         TEXT NOT NULL,
  description TEXT,
  is_system   BOOLEAN NOT NULL DEFAULT true,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(domain, key)
);
```

Tools/APIs use the **key** like `relationType: 'contains' | ...`, and the storage layer resolves `(domain, key) ‚Üí id` to record as `*_relation.relation_type_id`.

### 5.2 `card_link` (card ‚Üî code)

```sql
CREATE TABLE card_link (
  id              SERIAL PRIMARY KEY,
  project_id      TEXT NOT NULL REFERENCES project(id),
  workspace_id    TEXT NOT NULL REFERENCES workspace(id),
  card_identity_id  INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  code_identity_id  INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  anchor          JSONB NOT NULL,          -- LinkAnchor snapshot
  rationale       TEXT NOT NULL,
  weight          REAL NOT NULL DEFAULT 1.0
    CHECK (weight >= 0.0 AND weight <= 1.0),
  confidence      REAL
    CHECK (confidence IS NULL OR (confidence >= 0.0 AND confidence <= 1.0)),
  created_by      TEXT NOT NULL REFERENCES "user"(id),  -- v4.3 B-5: actor (user FK)
  stale_status    TEXT NOT NULL DEFAULT 'fresh'
    CHECK (stale_status IN ('fresh', 'stale_candidate', 'stale_confirmed')),
  verified_at     TIMESTAMPTZ,             -- Timestamp of last verification
  linked_at_card_version_id  INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  linked_at_code_version_id  INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  meta            JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE(card_identity_id, code_identity_id)
);

CREATE INDEX card_link_stale_idx ON card_link(stale_status) WHERE stale_status != 'fresh';
CREATE INDEX card_link_scope_idx ON card_link(project_id, workspace_id);
CREATE INDEX card_link_card_idx ON card_link(card_identity_id);
CREATE INDEX card_link_code_idx ON card_link(code_identity_id);
```

> **Same card‚Üîcode pair has a single link** (v4.2 F-3): Due to `UNIQUE(card_identity_id, code_identity_id)`, only one link exists between the same card and code. When a single code file implements multiple aspects of the same card, separate links are created at the **symbol level** (`symbol:path#functionName`). If multiple anchors are needed at the module level, auxiliary anchors are recorded in `card_link.meta`.

| Column | Description |
|------|------|
| `card_identity_id` | Card's identity (FK) |
| `code_identity_id` | Code entity's identity (FK) |
| `anchor` | Code identification snapshot at link creation time (`LinkAnchor`) |
| `rationale` | Why this code implements this card |
| `created_by` | Link creator (`"user".id` FK) (v4.3 B-5) |
| `stale_status` | `fresh` = valid, `stale_candidate` = version_num difference detected, `stale_confirmed` = anchor mismatch confirmed |
| `verified_at` | Timestamp of last successful stale verification |
| `linked_at_card_version_id` | Card version at link creation time |
| `linked_at_code_version_id` | Code version at link creation time |

#### LinkAnchor

```typescript
interface LinkAnchor {
  entityKey: string;
  symbolName: string | null;
  filePath: string;
  entityType: string;
  signatureText: string | null;
  symbolKind: string | null;
  versionId: number;
  contentHash: string | null;
}
```

### 5.3 `card_relation` (card ‚Üî card)

```sql
CREATE TABLE card_relation (
  id              SERIAL PRIMARY KEY,
  project_id      TEXT NOT NULL REFERENCES project(id),
  src_identity_id INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  dst_identity_id INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  relation_type_id SMALLINT NOT NULL REFERENCES relation_type_registry(id),
  meta            JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE(src_identity_id, dst_identity_id, relation_type_id)
);

CREATE INDEX card_rel_src_idx ON card_relation(project_id, src_identity_id, relation_type_id);
CREATE INDEX card_rel_dst_idx ON card_relation(project_id, dst_identity_id, relation_type_id);

-- In contains relation, a child(dst) can only have one parent (tree structure enforced by DB) (v4.2 A-1)
-- The contains id in relation_type_registry is fixed at seed time (see ¬ß14.4)
CREATE UNIQUE INDEX card_relation_single_parent
  ON card_relation(dst_identity_id)
  WHERE relation_type_id = 1;  -- contains type id (fixed at seed)
```

| relation_type(key) | Direction | Meaning | Cycles allowed |
|---------------|------|------|-----------|
| `contains` | parent ‚Üí child | Membership. Edge of nested tree | ‚ùå (tree) |
| `depends_on` | A ‚Üí B | A depends on B | ‚ùå (DAG) |
| `extends` | A ‚Üí B | A extends B | ‚úÖ (mutual extension allowed) |

#### Constraint Enforcement by relation_type

| relation_type | Constraint | Enforcement Location | Reason |
|--------------|------|----------|------|
| `contains` | **tree** (no cycles, single parent) | **DB partial unique index** (`card_relation_single_parent`) + **app-level** CTE cycle check | Single parent enforced at DB level, cycle check performed at app level (v4.2 A-1) |
| `depends_on` | **DAG** (no cycles) | **App-level** (CTE cycle check in `relate_cards`) | Same |
| `extends` | Cycles allowed | No constraint | Mutual extension possible |

> **Direct SQL INSERT defense**: Restrict INSERT privileges on the `card_relation` table to an app-only role. In production, block direct SQL INSERT to prevent bypassing app-level checks.

#### Edge Attribute Extensions (v3.1 review candidate)

Currently `weight`/`confidence` only exist on `card_link`. Edge attributes may also be needed for `card_relation`/`code_relation`:

| Table | Current | v3.1 Review |
|--------|------|-----------|
| `card_link` | `weight`, `confidence` ‚úÖ | ‚Äî |
| `card_relation` | `meta` JSONB only | Whether to add `strength` (strong/weak), `confidence` |
| `code_relation` | `strength` (inferred/manual) | Whether to add `confidence` |

> In v4, these are temporarily stored in `card_relation.meta`, and the decision to promote to dedicated columns will be made in v3.1 after evaluating usage patterns.

### 5.4 `code_relation` (code ‚Üî code)

```sql
CREATE TABLE code_relation (
  id              SERIAL PRIMARY KEY,
  workspace_id    TEXT NOT NULL REFERENCES workspace(id),
  src_identity_id INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  dst_identity_id INTEGER NOT NULL REFERENCES entity_identity(id) ON DELETE CASCADE,
  relation_type_id SMALLINT NOT NULL REFERENCES relation_type_registry(id),
  strength        TEXT NOT NULL DEFAULT 'inferred'
    CHECK (strength IN ('inferred', 'manual')),
  source_file     TEXT,           -- Which file parsing generated this
  meta            JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE(src_identity_id, dst_identity_id, relation_type_id)
);
```

> **Prior single `relation` table**: In v4, split into `card_link` + `card_relation` + `code_relation`. During migration, distributed by relation_type.

### 5.5 Connection Direction Extension

| Direction | Method | Description |
|------|------|------|
| code ‚Üí card | `link_card` manual | User/agent explicitly creates connection |
| code ‚Üí card | `@card` annotation auto | Parser recognizes `/** @card card::auth/login */` ‚Üí auto link |
| card ‚Üí code | glob pattern (v3.1) | `implementsPattern: "src/auth/**"` in card.meta ‚Üí auto matching |
| card ‚Üí external | external_refs | Jira, GitHub issue, Figma URL |

### 5.6 Graph Read Model (No VIEW/TABLE created)

A "graph-queryable data format" is needed for visualization/exploration, but v4 **does not create DB VIEW/TABLE**.
Instead, **standard query patterns** like below are used directly in tools/server.

#### (Example) Load card subtree + links in a single query

```sql
WITH contains_type AS (
  SELECT id FROM relation_type_registry
  WHERE domain = 'card_relation' AND key = 'contains'
),
subtree AS (
  SELECT :root_card_id::int AS card_id, 0 AS depth
  UNION ALL
  SELECT cr.dst_identity_id, st.depth + 1
  FROM card_relation cr
  JOIN subtree st ON st.card_id = cr.src_identity_id
  WHERE cr.project_id = :project_id
    AND cr.relation_type_id = (SELECT id FROM contains_type)
    AND st.depth < :max_depth
)
SELECT
  st.card_id,
  ev.entity_key AS card_key,
  ev.card_status,
  ev.card_priority,
  ev.card_tags,
  ev.card_weight,
  ev.card_body,
  cl.id AS link_id,
  cl.code_identity_id
FROM subtree st
JOIN entity_version ev ON ev.identity_id = st.card_id AND ev.status = 'active'
LEFT JOIN card_link cl ON cl.card_identity_id = st.card_id
  AND cl.project_id = :project_id
  AND cl.workspace_id = :workspace_id;
```

---

## 6. Evidence Model

### 6.1 Polymorphic Evidence

The prior design's `relation_evidence` is expanded to `card_evidence` in v4. Connected to card_link.

```sql
CREATE TABLE card_evidence (
  id              SERIAL PRIMARY KEY,
  card_link_id    INTEGER NOT NULL REFERENCES card_link(id) ON DELETE CASCADE,
  evidence_type   TEXT NOT NULL
    CHECK (evidence_type IN ('code_link', 'test_pass', 'annotation', 'manual_review', 'ai_verification')),
  fact_id         INTEGER REFERENCES fact(id) ON DELETE SET NULL,
  version_id      INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  is_active       BOOLEAN NOT NULL DEFAULT true,
  snapshot        JSONB,           -- Referenceable even after fact/evidence deletion
  meta            JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX card_evidence_link_active_idx ON card_evidence(card_link_id, is_active);
CREATE INDEX card_evidence_type_idx ON card_evidence(evidence_type);
```

> **Extensibility note**: `evidence_type` currently uses a CHECK constraint fixing 5 types. An `evidence_type_registry` table could be introduced following the same pattern as `relation_type_registry`, but in v4 the evidence types are stable (5 types) so CHECK is maintained. If new evidence types are added frequently, transition to a registry in v3.1. Migration DDL: `ALTER TABLE card_evidence DROP CONSTRAINT ...; ADD COLUMN evidence_type_id SMALLINT REFERENCES evidence_type_registry(id);`

### 6.2 Collection Paths by Evidence Type

| Type | Collection Path | is_active Transition |
|------|----------|---------------|
| `code_link` | Auto-created on `link_card` tool call | Re-verified on new version parse ‚Üí updated |
| `test_pass` | CI result integration (v3.1) | `is_active=false` on test failure |
| `annotation` | When parser detects `@card` annotation | `is_active=false` when annotation removed |
| `manual_review` | Explicitly recorded by user | Explicitly invalidated by user |
| `ai_verification` | On AI verification tool call (v3.1) | Updated on re-verification |

### 6.3 Evidence and is_active Transition Timing

In the sync worker `processFile()` flow:
1. Parser parses entities from the current file
2. Query `card_link`s connected to the entity's identity
3. For each card_link's evidence where `evidence_type = 'code_link'`:
   - Confirmed in current parse ‚Üí maintained (`is_active=true`)
   - Not confirmed ‚Üí transition to `is_active=false`
4. `annotation` type follows the same pattern: active if `@card` annotation exists, inactive if not

---

## 7. Composite Coverage

### 7.1 Coverage Calculation Model

#### Leaf Coverage

Coverage for leaf cards (cards with no children):
- If at least one `card_link` with `stale_status = 'fresh'` exists and that link has a `card_evidence` with `is_active = true` ‚Üí **covered**
- If the above condition is not met ‚Üí **uncovered**

> **v4.4 P-1, P-2**: Coverage calculation (1) excludes stale links and (2) only recognizes links with active evidence as valid implementations. Links without evidence or stale links do not contribute to coverage.

#### Subtree Coverage (Recursive Weighted Aggregation)

```
coverage(card) =
  if card is leaf:
    1.0 if covered, 0.0 if uncovered
  else:
    Œ£(child.weight √ó coverage(child)) / Œ£(child.weight)
```

```sql
WITH contains_type AS (
  SELECT id
  FROM relation_type_registry
  WHERE domain = 'card_relation' AND key = 'contains'
),
card_tree AS (
  -- base: direct children of target card
  SELECT cr.dst_identity_id AS card_id, 1 AS depth
  FROM card_relation cr
  WHERE cr.src_identity_id = {target_card_id}
    AND cr.relation_type_id = (SELECT id FROM contains_type)
  UNION ALL
  -- recursive: children of children
  SELECT cr.dst_identity_id, ct.depth + 1
  FROM card_relation cr
  JOIN card_tree ct ON ct.card_id = cr.src_identity_id
  WHERE cr.relation_type_id = (SELECT id FROM contains_type)
    AND ct.depth < 50  -- depth limit
)
SELECT
  ct.card_id,
  ev.entity_key AS card_key,
  COALESCE(ev.card_weight, 1.0) AS weight,
  CASE WHEN COUNT(ce.id) > 0 THEN 1.0 ELSE 0.0 END AS leaf_coverage  -- v4.4 P-1: evidence-based
FROM card_tree ct
JOIN entity_version ev ON ev.identity_id = ct.card_id AND ev.status = 'active'
LEFT JOIN card_link cl ON cl.card_identity_id = ct.card_id
  AND cl.stale_status = 'fresh'                                       -- v4.4 P-2: exclude stale links
  AND (:workspace_id IS NULL OR cl.workspace_id = :workspace_id)       -- v4.3 C-1: workspace filter
LEFT JOIN card_evidence ce ON ce.card_link_id = cl.id
  AND ce.is_active = true                                              -- v4.4 P-1: active evidence only
GROUP BY ct.card_id, ev.entity_key, ev.card_weight;
```

> **Subtree aggregation strategy** (v4.7 F-9): The above SQL only calculates **leaf coverage** (each card's `leaf_coverage` value). Recursive weighted aggregation (`coverage(parent) = Œ£(child.weight √ó coverage(child)) / Œ£(child.weight)`) is **performed bottom-up at the app level**:
> 1. Collect above SQL results into a Map by card_id
> 2. Process in reverse order starting from the deepest (leaf) depth in card_tree
> 3. Cards with no children ‚Üí use leaf_coverage
> 4. Cards with children ‚Üí weighted average of children's coverage by weight
>
> Implementing recursive weighted aggregation in SQL alone results in nested CTEs with poor readability/performance, so leaf data is extracted via SQL and aggregation is separated to an app-level loop.

### 7.2 Tag-based Cross-cutting Aggregation

Independent of tree structure, aggregate coverage of cards with a specific tag:

```sql
SELECT
  tag,
  COUNT(DISTINCT ev.identity_id) AS total_cards,
  COUNT(DISTINCT CASE WHEN ce.id IS NOT NULL THEN ev.identity_id END) AS covered_cards,  -- v4.4 P-1: evidence-based
  ROUND(
    COUNT(DISTINCT CASE WHEN ce.id IS NOT NULL THEN ev.identity_id END)::numeric
    / NULLIF(COUNT(DISTINCT ev.identity_id), 0)::numeric * 100, 1
  ) AS coverage_pct
FROM entity_version ev
CROSS JOIN LATERAL unnest(ev.card_tags) AS tag
LEFT JOIN card_link cl ON cl.card_identity_id = ev.identity_id
  AND cl.stale_status = 'fresh'                                       -- v4.4 P-2: exclude stale links
  AND (:workspace_id IS NULL OR cl.workspace_id = :workspace_id)       -- v4.3 C-2: workspace filter
LEFT JOIN card_evidence ce ON ce.card_link_id = cl.id
  AND ce.is_active = true                                              -- v4.4 P-1: active evidence only
WHERE ev.status = 'active'
  AND ev.identity_id IN (
    SELECT id FROM entity_identity WHERE entity_type_id = {card_type_id}
  )
GROUP BY tag;
```

### 7.3 Priority-based Filtering

```sql
-- Unimplemented P0 cards (v4.5 M-1: same evidence+stale criteria as ¬ß7.1)
SELECT ev.entity_key, ev.card_status AS status
FROM entity_version ev
WHERE ev.status = 'active'
  AND ev.card_priority = 'P0'
  AND ev.identity_id NOT IN (
    SELECT cl.card_identity_id
    FROM card_link cl
    JOIN card_evidence ce ON ce.card_link_id = cl.id AND ce.is_active = true
    WHERE cl.stale_status = 'fresh'
  );
```

---

## 8. Governance Model (Approval Event)

### 8.1 Core Principle

**The system's truth is the approval log, not inference.**

### 8.2 `approval_event` Schema

```sql
CREATE TABLE approval_event (
  id              SERIAL PRIMARY KEY,
  project_id      TEXT NOT NULL REFERENCES project(id),
  workspace_id    TEXT REFERENCES workspace(id),
  event_type      TEXT NOT NULL
    CHECK (event_type IN (
      'link_created', 'link_updated', 'link_removed', 'link_staled',
      'identity_rewritten', 'identity_merged',
      'link_rollback',
      'card_registered', 'card_updated',
      'card_status_changed',
      'card_relation_created', 'card_relation_updated', 'card_relation_removed',
      'card_reparented'
    )),
  actor_id        TEXT NOT NULL REFERENCES "user"(id),  -- v4.3 B-2: actor (user FK)
  target_card_link_id   INTEGER REFERENCES card_link(id) ON DELETE SET NULL,
  target_identity_id    INTEGER REFERENCES entity_identity(id) ON DELETE SET NULL,
  target_card_relation_id INTEGER REFERENCES card_relation(id) ON DELETE SET NULL,
  payload         JSONB NOT NULL,
  rationale       TEXT,
  parent_event_id INTEGER REFERENCES approval_event(id),  -- causal relationship (see usage below)
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX approval_target_link_idx ON approval_event(target_card_link_id);
CREATE INDEX approval_target_identity_idx ON approval_event(target_identity_id);
CREATE INDEX approval_project_time_idx ON approval_event(project_id, created_at DESC);
CREATE INDEX approval_workspace_time_idx ON approval_event(workspace_id, created_at DESC) WHERE workspace_id IS NOT NULL;
CREATE INDEX approval_actor_idx ON approval_event(actor_id);
```

> **`parent_event_id` usage scenarios** (v4.2 C-5):
> - **deprecated propagation**: parent card's `card_status_changed` event ‚Üí each child's individual event's `parent_event_id` references the parent event
> - **rollback**: `link_rollback` event's `parent_event_id` references the original `link_created` event
> - **link migration after identity merge**: merge event as parent, each migrated link's `link_updated` event references it
> - NULL when not applicable. The causal chain is reconstructed via `parent_event_id` during queries.

> **Extensibility note**: The `event_type` CHECK constraint is not split into a registry table unlike `relation_type_registry`. Reasons:
> - approval_event is an **audit log** so new type additions are infrequent (only when tools are added)
> - CHECK constraint provides stronger integrity guarantees for audit data
> - New event_type additions are handled via `ALTER TABLE ... DROP CONSTRAINT ... ADD CONSTRAINT ...` DDL migration
> - Registry conversion will be reconsidered when a tool plugin system is introduced in v3.1

> **Event creation paths** (v4.7 F-3):
> - `link_removed`: Generated on explicit deletion via `unlink_card` tool, or when rolling back `link_created` via `rollback_approval`. **Accompanied by physical card_link DELETE.**
> - `link_staled`: Generated when a card transitions to `deprecated`, marking associated card_links as `stale_confirmed`. **card_link record is preserved** (see ¬ß4.5).
> - Why this distinction matters: rollback of `link_removed` recreates the card_link, while rollback of `link_staled` restores the stale_status to its previous value.

### 8.3 Tool-Event Mapping

| Tool Call | Generated approval_event |
|-----------|------------------------|
| `register_card` (new) | `card_registered` |
| `register_card` (update) | `card_updated` |
| `update_card_status` | `card_status_changed` |
| `link_card` (new) | `link_created` |
| `link_card` (existing update) | `link_updated` |
| `unlink_card` | `link_removed` |
| `update_card_status`(deprecated) | `link_staled` (v4.7 F-3: stale marking only, not deletion) |
| `move_card` | `card_reparented` |
| `relate_cards` (new) | `card_relation_created` |
| `relate_cards` (existing update) | `card_relation_updated` |
| `apply_identity_rewrite` | `identity_rewritten` |
| `rollback_approval` | `link_rollback` |
| identity merge (system auto) | `identity_merged` |

> **actor_id recording principle** (v4.3 B-2): Every approval_event's `actor_id` records the `"user".id` of the user who triggered the operation. Even for system-automated operations like identity merge, the `user_id` config value of the MCP instance that executed the sync is recorded. When an agent calls a tool, the ID of the user operating the agent is recorded ‚Äî responsibility for actions always belongs to the user (¬ß2.7 Design Principle 1).

### 8.4 Payload Validation

Required fields are validated for each event_type's payload:

```typescript
const PAYLOAD_SCHEMAS: Record<string, z.ZodSchema> = {
  link_created: z.object({
    cardLinkId: z.number(),
    cardIdentityId: z.number(),
    cardKey: z.string(),
    codeIdentityId: z.number(),
    codeEntityKey: z.string(),
    anchor: LinkAnchorSchema,
    rationale: z.string(),
    cardVersionId: z.number(),
    codeVersionId: z.number(),
  }),
  card_status_changed: z.object({
    cardKey: z.string(),
    identityId: z.number(),
    fromStatus: CardStatusSchema,
    toStatus: CardStatusSchema,
    propagatedChildren: z.array(z.string()),
  }),
  // ... schema per event_type
};
```

> On payload validation failure, event creation is rejected and an error is returned.

### 8.5 Reversibility

`rollback_approval` tool:

| event_type | compensating action |
|-----------|-------------------|
| `link_created` | Delete card_link (generates link_removed event) |
| `link_updated` | Restore card_link.meta to payload.before |
| `link_removed` | Recreate card_link |
| `link_staled` | Restore card_link.stale_status to payload.before.stale_status (v4.7 F-3) |
| `identity_rewritten` | Restore card_link's code_identity_id to original value |
| `identity_merged` | Reverse-migrate version/relation back to original identity |
| `card_registered` | Delete version + delete identity (cascade) |
| `card_updated` | Restore previous version to active, delete current version |
| `card_status_changed` | Restore to previous status. **Since individual events exist per child** (v4.2 D-5), children can be rolled back individually. On parent rollback, child events linked via `parent_event_id` are also auto-rolled back |
| `card_relation_created` | Delete the card_relation |
| `card_relation_updated` | Restore card_relation.meta to previous state |
| `card_reparented` | Re-move to previous parent |

> On `identity_merged` rollback, causal order is checked: if approval_events created after the merge reference the identity, rollback is rejected. Reference is determined by `target_identity_id = merged_identity_id` OR identity references within payload.

### 8.6 Provenance Chain

Query full history for a specific card_link:

```sql
SELECT ae.*
FROM approval_event ae
WHERE ae.target_card_link_id = {card_link_id}
ORDER BY ae.created_at ASC;
```

### 8.7 entity_lifecycle vs approval_event Dual Recording Boundary

Some events overlap in the roles of both tables. Principle:

| Event | entity_lifecycle | approval_event | Notes |
|--------|:---:|:---:|------|
| identity creation (sync auto) | ‚úÖ `created` | ‚ùå | Auto events: lifecycle only |
| identity creation (register_card) | ‚úÖ `created` | ‚úÖ `card_registered` | Manual tools: both |
| version update (sync) | ‚úÖ `updated` | ‚ùå | |
| version update (register_card) | ‚úÖ `updated` | ‚úÖ `card_updated` | |
| identity merge (auto) | ‚úÖ `merged` | ‚úÖ `identity_merged` | **Exception**: auto but audit-mandatory, so both |
| status change | ‚úÖ `status_changed` | ‚úÖ `card_status_changed` | |
| reparent | ‚úÖ `reparented` | ‚úÖ `card_reparented` | |
| rename (sync detected) | ‚úÖ `renamed` | ‚ùå | |
| link create/delete | ‚ùå | ‚úÖ `link_*` | Links: approval only |

**Principle**: `approval_event` records only **governance audit** (manual tools, approval-required operations). `entity_lifecycle` records **all identity state changes**. When recording in both, they are recorded **atomically within a single transaction**.

```typescript
// Example: inside register_card
await db.transaction(async (tx) => {
  const version = await createVersion(tx, ...);
  await recordLifecycle(tx, { identityId, eventType: 'created', toVersionId: version.id });
  await recordApproval(tx, { eventType: 'card_registered', payload: {...} });
});
```

---

## 9. Hierarchical Defense Strategy (3-Tier Defense)

> identity/version separation is the core. 3-tier defense guarantees link preservation during file moves/renames.

### 9.1 Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Tier 1: content_hash-based identity matching    ‚îÇ ‚Üê Auto (deterministic)
‚îÇ  Target: File moves (content unchanged)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Tier 2: resolve_identity_candidates             ‚îÇ ‚Üê Semi-auto (human approval)
‚îÇ  Target: File split/merge, symbol rename         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Tier 3: register_card / link_card               ‚îÇ ‚Üê Manual (discussion-based)
‚îÇ  Target: New card registration, new link creation‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 9.2 Tier 1: content_hash Identity Matching

Main flows:

**On startupScan**:
1. Cross-compare `scanFiles()` results with DB active versions
2. 1:1 pairs with identical content_hash ‚Üí existing version archived, new version active on same identity
3. 1:N, N:1, hash mismatch ‚Üí existing version archived, new identity created

**On Watch events**:
- DELETE: version archived. identity + card_link preserved (protected by identity)
- CREATE: search archived versions by content_hash ‚Üí if match found, link to same identity

**Watch reverse order (CREATE‚ÜíDELETE) defense**: Post-DELETE Identity Merge Check ‚Äî after DELETE processing, if a new version with the same content_hash already exists, auto merge is performed.

> **Cross-workspace identity merge policy** (v4.2 C-2): Identity merge is performed **only within the same workspace**. Even if the same file exists in another workspace (branch), they are managed as independent identities. Reasons:
> - Each branch has an independent code state
> - Merging identities across branches would break consistency on branch switch
> - card_link includes workspace_id, so the same card can be linked to the same file in different branches independently (T9-4)

#### card_link Migration on Identity Merge (v4 addition)

In v4, `card_link.code_identity_id` must be updated:

```sql
-- merge: old_identity ‚Üí surviving_identity
-- Step 1: Migrate card_link's code_identity_id
UPDATE card_link
SET code_identity_id = :surviving_identity_id,
    updated_at = now()
WHERE code_identity_id = :old_identity_id;

-- Step 2: On UNIQUE conflict (duplicate card‚Üîcode pair) ‚Üí keep existing link, delete new link
-- ON CONFLICT handling is done with pre-check at app level
```

> After merge, the payload of `approval_event(identity_merged)` includes the list of migrated card_link IDs. Used for reverse migration on rollback.

#### Symbol-level Identity Cascade

When module identity matching succeeds and a file move is detected, **child symbol entities** must also be handled:

1. Query the list of symbol identities linked to the moved module's existing active version
2. For each symbol:
   - If the same symbolName exists in the new file ‚Üí add a new version to that symbol identity (auto)
   - If not found ‚Üí existing symbol version archived. If card_link exists, delegate to Tier 2
3. Record `event_type: 'renamed'` in `entity_lifecycle` (per symbol)

### 9.3 Tier 2: Identity Resolution

Candidates are presented via `resolve_identity_candidates`, and identity is rewritten after user approval via `apply_identity_rewrite`. See ¬ß12.3 for detailed tool interface.

### 9.4 Concurrency Critical Section

In v4, Advisory Locks are deferred to v3.1, but the following operations are identified as **critical sections**:

| Critical Section | Risk Scenario | v4 Interim Defense | v3.1 Target |
|-----------------|-------------|-------------|-----------|
| `identity_merge` | Concurrent merge attempts on the same identity | `SERIALIZABLE` isolation | `pg_advisory_xact_lock(identity_id)` |
| `link_card` (UPSERT) | Concurrent link of the same card‚Üîcode pair | `ON CONFLICT` clause | advisory lock |
| `apply_identity_rewrite` | Concurrent rewrite of the same identity | `SERIALIZABLE` isolation | advisory lock |
| `move_card` | Concurrent move of the same card to different parents | `SERIALIZABLE` isolation | advisory lock |
| `update_card_status` (propagation) | Child status change during parent deprecated | `SELECT ... FOR UPDATE` on parent version | advisory lock |
| Watch event processing | Concurrent DELETE+CREATE on the same file | Event serialization (debounce queue) | advisory lock |

> **v4 scope**: All critical sections use `SERIALIZABLE` or `SELECT ... FOR UPDATE`. If performance degradation is observed, transition to advisory locks in v3.1.

```typescript
// Example: identity_merge critical section
await db.transaction(async (tx) => {
  // Lock both identities with FOR UPDATE (deadlock prevention: always lock in ascending id order)
  const [id1, id2] = [oldIdentityId, survivingIdentityId].sort((a, b) => a - b);
  await tx.execute(sql`SELECT 1 FROM entity_identity WHERE id IN (${id1}, ${id2}) FOR UPDATE`);
  // ... merge logic
});
```

#### Serialization Failure Retry (v4.2 D-4)

PostgreSQL `SERIALIZABLE` isolation level can produce serialization failures (SQLSTATE `40001`). All critical sections use an **automatic retry wrapper**:

```typescript
async function withSerializableRetry<T>(
  db: DrizzleClient,
  fn: (tx: Transaction) => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await db.transaction(fn, { isolationLevel: 'serializable' });
    } catch (e: unknown) {
      const isSerializationFailure = e instanceof Error && 'code' in e && (e as any).code === '40001';
      if (isSerializationFailure && attempt < maxRetries - 1) {
        // exponential backoff: 10ms, 20ms, 40ms
        await new Promise(r => setTimeout(r, 10 * Math.pow(2, attempt)));
        continue;
      }
      throw e;
    }
  }
  throw new Error('unreachable');
}
```

> This wrapper applies to SERIALIZABLE critical sections in the ¬ß9.4 table: `identity_merge`, `apply_identity_rewrite`, `move_card`, etc.
>
> **Monitoring metrics** (v4.5 I-2): Serialization failure frequency may increase with N concurrent users. The following metrics are recorded in `sync_run.meta` or a separate log for v3.1 advisory lock transition decisions:
> - `serialization_retries`: Number of retries that occurred for the operation
> - `serialization_failures`: Number of failures exceeding max retries
> - `avg_retry_delay_ms`: Average retry wait time

### 9.5 Tier 3: Manual Tools

Prior spec tools changed to card-centric. Tool name changes:
- `register_spec` ‚Üí `register_card`
- `link_spec` ‚Üí `link_card`
- `relate_specs` ‚Üí `relate_cards`
- `spec_impact` ‚Üí `card_impact`
- `kb_status` ‚Üí `card_dashboard` (v4.2 E-2: renamed to avoid confusion with `card_status` column)

(Details defined in ¬ß13)

---

## 10. Sync Worker

### 10.1 Core Loop

Centered on version append. On file change, the existing version transitions to archived and a new version is added.

#### `processFile()` Changes

Added to existing `processFile()`:
- `@card` annotation parsing ‚Üí auto `card_link` creation (evidence_type: `annotation`)
- If existing annotation evidence is no longer present ‚Üí transition to `is_active=false`

#### `@card` Parsing Error Handling (v4.2 C-4)

| Situation | Handling |
|------|------|
| Referenced card does not exist | Record warning in `sync_event` (`action: 'warning'`, `meta: {reason: 'card_not_found', cardKey, filePath}`). Do not create card_link |
| card_key format is invalid | Ignore + record warning in `sync_event` |
| Referenced card is `deprecated` | Create card_link but with `stale_status = 'stale_confirmed'`. Record warning |
| Card does not exist in workspace.project_id | Record warning in `sync_event`. Do not create card_link |

> `@card` parsing failure **does not abort sync**. Only a warning is recorded and processing continues for remaining files.

### 10.2 Orphan Cleanup

**code_relation orphan**: Scoped to parsed file + excludes `strength='manual'`.

**card_link orphan prohibition**: card_links are manually created so sync does not auto-delete them. Only stale marking.

### 10.3 `__manual__/` Path Protection

5-layer filtering: (1) `.gitignore` (2) `node_modules/` (3) `__manual__/` prefix (4) config file extensions (5) binary detection. Sources under `__manual__/` paths are completely excluded from sync targets.

### 10.4 Stale Link Detection

Stale detection of existing card_links on card update:

1. On `card_updated` event
2. Query all card_links of the card
3. For each link:
   - Compare `linked_at_card_version_id`'s `version_num` vs current card's `version_num`
   - Difference ‚â• 1 ‚Üí `stale_status = 'stale_candidate'`
   - If anchor keyword does not match in current card body ‚Üí `stale_status = 'stale_confirmed'`
4. Include stale links in `inconsistency_report`

---

## 11. Purge/Archive Model

### 11.1 Version Purge

TTL-based physical deletion of archived versions:

```sql
-- Step 1: Set entity_lifecycle version FK to NULL
UPDATE entity_lifecycle
SET from_version_id = NULL
WHERE from_version_id IN (
  SELECT id FROM entity_version
  WHERE status = 'archived'
    AND created_at < now() - {olderThanDays} * interval '1 day'
);

UPDATE entity_lifecycle
SET to_version_id = NULL
WHERE to_version_id IN (
  SELECT id FROM entity_version
  WHERE status = 'archived'
    AND created_at < now() - {olderThanDays} * interval '1 day'
);

-- Step 2: Preserve card_evidence snapshot
UPDATE card_evidence ce
SET snapshot = jsonb_build_object(
      'factKey', f.fact_key,
      'factPayload', f.payload,
      'entityKey', ev.entity_key,
      'contentHash', ev.content_hash
    ),
    is_active = false
FROM fact f
JOIN entity_version ev ON ev.id = f.version_id
WHERE ce.fact_id = f.id
  AND ev.status = 'archived'
  AND ev.created_at < now() - {olderThanDays} * interval '1 day'
  AND ce.snapshot IS NULL;

-- Step 3: Delete archived versions (fact/source FK cascade)
DELETE FROM entity_version
WHERE status = 'archived'
  AND created_at < now() - {olderThanDays} * interval '1 day';
```

### 11.2 Identity Purge

Clean up identities with all versions deleted after TTL (COALESCE fallback also handles identities without lifecycle records):

```sql
DELETE FROM entity_identity ei
WHERE NOT EXISTS (
  SELECT 1 FROM entity_version ev WHERE ev.identity_id = ei.id
)
AND COALESCE(
  (SELECT MAX(el.created_at) FROM entity_lifecycle el WHERE el.identity_id = ei.id),
  ei.created_at  -- fallback: use identity creation time if no lifecycle exists
) < now() - {olderThanDays} * interval '1 day'
AND NOT EXISTS (
  SELECT 1 FROM card_link cl
  WHERE cl.card_identity_id = ei.id OR cl.code_identity_id = ei.id
);
```

> **Protection condition**: Identities participating in card_link are not purged. card_link itself serves as an identity protection mechanism.

### 11.3 Protection Release Paths

| Release Condition | Description |
|-----------|------|
| card_link migrated via `apply_identity_rewrite` | Purgeable once no links remain on old identity |
| Link deleted via `unlink_card` | Link released |
| Link cleanup on card `deprecated` transition | Code identity protection released after cleaning deprecated card's links |

### 11.4 Workspace Archive Procedure (v4.3 A-4, full replacement of former v4.2 A-3)

Workspaces are **archived, not deleted** (append-only principle, ¬ß2.7). No ON DELETE CASCADE in DDL, and workspace records themselves are never DELETEd.

```sql
-- Step 1: Transition workspace's code entity versions to archived
UPDATE entity_version
SET status = 'archived'
WHERE workspace_id = :workspace_id AND status = 'active';

-- Step 2: Mark workspace's card_links as stale (v4.7 F-7: includes candidates)
UPDATE card_link
SET stale_status = 'stale_confirmed', updated_at = now()
WHERE workspace_id = :workspace_id AND stale_status IN ('fresh', 'stale_candidate');

-- Step 3: Transition workspace itself to archived
UPDATE workspace
SET status = 'archived', updated_at = now()
WHERE id = :workspace_id;
```

> **No DELETEs**: workspace, card_link, entity_identity, code_relation, sync_run are all never deleted. Once a workspace is archived, all its data is permanently preserved for audit/history purposes.
>
> **code_relation handling** (v4.4 P-3): code_relation is workspace-scoped and is preserved as-is during archive without separate state changes. Since queries filter by workspace_id to only retrieve active workspace data, archived workspace's code_relations are naturally excluded (see ¬ß2.7 query patterns).
>
> **On recreation with the same branch_name** (v4.3 A-3): The previous workspace is in archived state, so the `workspace_project_branch_unique` partial unique index (`WHERE status = 'active'`) allows a **new workspace to be created** without conflict. No reactivation occurs ‚Äî even branches with the same name have completely different code states at different points in time, preventing old data contamination.
>
> **entity_identity cleanup**: Identity purge (¬ß11.2) cleans up identities with no active versions.

### 11.5 Post-Merge card_link Migration Policy (v4.3 F-1)

card_link handling after a feature branch is merged into main:

| Link Type | Migrated to main | Reason |
|-----------|---------------|------|
| `@card` annotation-based | **Auto** | main's Sync Worker parses the code and recreates card_links |
| Manual/agent link | **Not auto-migrated** | main's code identity is separate (cross-workspace merge prohibited). Agent must reconnect on main |

> **Intentional design**: If manual links from branches were automatically migrated to main, there is a risk of unverified links flowing into main. Links on main must be explicitly created on main.

---

## 12. MCP Tools

### 12.1 Card Tools

> **Scope rules (common to all tools)**
> - card/card_relation/approval_event are **project scope**, so inputs include `projectId`.
> - code/code_relation/card_link are **workspace scope**, so tools involving code include `workspaceId`.

#### `register_card`

Registers/updates a card entity in the KB.

```typescript
interface RegisterCardInput {
  /** project scope */
  projectId: string;
  /** Card key. e.g.: "card::auth", "card::auth/login" */
  cardKey: string;
  /** Card summary (1-2 lines) */
  summary: string;
  /** Card body (markdown) */
  body: string;
  /** Parent card key (optional). e.g.: "card::auth". Omit for root card */
  parentCardKey?: string;
  /** Initial status (default: 'draft') */
  status?: CardStatus;
  /** Priority */
  priority?: CardPriority;
  /** Tags */
  tags?: string[];
  /** Coverage weight (0.0 ~ 1.0, default: 1.0) */
  weight?: number;
  /** Card template type */
  templateType?: CardTemplateType;
  /** External references */
  externalRefs?: ExternalRef[];
  /** Acceptance criteria */
  acceptanceCriteria?: AcceptanceCriterion[];
  /** Additional meta */
  meta?: Record<string, unknown>;
}
```

**Operation procedure** (single transaction):

1. **Identity create/lookup**: Query by `stable_key = cardKey`. If not found, create with `entity_type = 'card'`
2. **Version create/update**: Determined by versioning policy below

> **Card versioning policy** (v4.7 F-4):
> - **Version increment targets (content_hash computed fields)**: `body`, `summary`, `acceptanceCriteria`. If any of these fields change, `content_hash = SHA-256(body + summary + JSON.stringify(acceptanceCriteria))` differs so a new version is created (existing version archived, version_num++). Stale detection is also triggered.
> - **In-place update targets**: `priority`, `tags`, `weight`, `templateType`, `externalRefs`, `meta`. If only these fields change, the current active version's columns are updated directly and version_num does not increment. `card_updated` approval_event is created with `payload.versionChanged = false`.
> - **status**: Can only be changed via `update_card_status` tool (cannot be changed in register_card, only settable at initial registration)
3. **Source creation**: `kind: "card"`, `file_path: "__manual__/card/{cardKey}"`, `file_hash: content_hash` (v4.2 C-6)
4. **Fact creation**: `fact_type: "card_body"`, `payload_text: body`. (v4.2 B-3: fact is the reference target for `card_evidence.fact_id` and for FTS auxiliary indexing. `entity_version.card_body` is the SSOT, fact is the reference point in the evidence chain. On update, both sides are updated atomically in a single transaction)
5. **Contains relation auto-creation**: When `parentCardKey` is specified
   - Query parent identity ‚Üí error if not found
  - `card_relation` INSERT (`relationType: 'contains'` ‚Üí registry resolve ‚Üí `relation_type_id`, `src = parent`, `dst = this`)
6. **Approval event**: `card_registered` or `card_updated`
7. **Entity lifecycle**: `created` or `updated`

```typescript
interface RegisterCardResult {
  cardKey: string;
  identityId: number;
  versionId: number;
  versionNum: number;
  action: 'created' | 'updated' | 'unchanged';
}
```

#### `link_card`

Creates a link between a card and a code entity.

```typescript
interface LinkCardInput {
  /** project scope (card's SSOT) */
  projectId: string;
  /** workspace scope (code indexing unit) */
  workspaceId: string;
  /** Code entity key */
  codeEntityKey: string;
  /** Card key */
  cardKey: string;
  /** Why this code implements this card */
  rationale: string;

  /** Edge attributes (optional) */
  weight?: number;
  confidence?: number;
}
```

**Operation procedure** (single transaction):

1. **Code entity verification**: Confirm active version exists
2. **Card entity verification**: Query identity by stable_key
3. **Anchor collection**: Construct LinkAnchor from code entity's facts
4. **card_link create/update** (UPSERT on unique constraint)
5. **card_evidence creation**: `evidence_type: 'code_link'`
6. **Approval event**: `link_created` or `link_updated`

#### `unlink_card`

Deletes a link between a card and code.

```typescript
type UnlinkCardInput =
  | {
      projectId: string;
      workspaceId: string;
      cardLinkId: number;
      reason: string;
    }
  | {
      projectId: string;
      workspaceId: string;
      cardKey: string;
      codeEntityKey: string;
      reason: string;
    };
```

**Behavior**: Delete card_link + generate `link_removed` approval_event.

#### Deprecated card ‚Üí Link Migration to Another Card Workflow (v4.2 D-2)

Standard procedure for migrating a deprecated card's code links to another card:

1. Check the deprecated card's stale link list via `card_dashboard` (or `inconsistency_report`)
2. For each link:
   - `unlink_card({ cardKey: deprecatedCardKey, codeEntityKey, reason: "migrating to new card" })`
   - `link_card({ cardKey: newCardKey, codeEntityKey, rationale: "migrated from deprecated card::..." })`
3. After migration is complete and all links of the deprecated card are cleaned up, purge protection of code identities is released

> Direct `link_card` to a deprecated card is not allowed (¬ß13.2). Must follow `unlink` ‚Üí `link` order.

#### `move_card`

Changes a card's parent (reparent).

```typescript
interface MoveCardInput {
  /** project scope */
  projectId: string;
  /** Card key to move */
  cardKey: string;
  /** New parent card key (null to move to root) */
  newParentCardKey: string | null;
  /** Reason for move */
  reason: string;
}
```

**Operation procedure**:
1. Cycle check: Confirm new parent is not a descendant of cardKey (CTE below)
2. Delete existing `contains` relation
3. Create new `contains` relation (if newParentCardKey is provided)
4. Record `reparented` event in `entity_lifecycle`
5. Record `card_reparented` in `approval_event`

**Cycle check CTE**:

```sql
WITH RECURSIVE contains_type AS (
  SELECT id FROM relation_type_registry
  WHERE domain = 'card_relation' AND key = 'contains'
),
descendants AS (
  -- base: cardKey itself
  SELECT :card_identity_id::int AS id, 0 AS depth
  UNION ALL
  -- recursive: all descendants of cardKey
  SELECT cr.dst_identity_id, d.depth + 1
  FROM card_relation cr
  JOIN descendants d ON d.id = cr.src_identity_id
  WHERE cr.relation_type_id = (SELECT id FROM contains_type)
    AND d.depth < 50
)
SELECT EXISTS (
  SELECT 1 FROM descendants WHERE id = :new_parent_identity_id
) AS is_circular;
-- If is_circular = true, error: "Circular reference detected"
```

#### `update_card_status`

Transitions a card's lifecycle state.

```typescript
interface UpdateCardStatusInput {
  /** project scope */
  projectId: string;
  cardKey: string;
  newStatus: CardStatus;
  reason?: string;
}
```

**Operation procedure**:
1. Query current status
2. Validate transition rules (`CARD_STATUS_TRANSITIONS`)
3. Change status (update `card_status` on active version)
4. **Downward propagation**: On `deprecated` transition, all descendants also deprecated (recursive)
5. Record `card_status_changed` in `approval_event`

#### `relate_cards`

Creates a `depends_on` or `extends` relationship between cards.

```typescript
interface RelateCardsInput {
  /** project scope */
  projectId: string;
  srcKey: string;
  dstKey: string;
  relationType: 'depends_on' | 'extends';
  rationale: string;
}
```

Cycle check for `depends_on` (recursive CTE, depth 50).

#### `unrelate_cards`

Deletes a relationship between cards.

```typescript
interface UnrelateCardsInput {
  /** project scope */
  projectId: string;
  srcKey: string;
  dstKey: string;
  relationType: 'contains' | 'depends_on' | 'extends';
  reason: string;
}
```

> Warning returned on `contains` deletion to prevent child card from becoming orphaned.

### 12.2 Analysis Tools

#### `card_impact`

Recursively explores the code and card list affected by a specific card change.

Card-centric impact analysis:
- **Bidirectional traversal**: 
  - Reverse: code referencing the card (card_link)
  - Forward: card's children (contains), depends_on, extends
- `contains` relation is traversed **forward** (src ‚Üí dst) to find child cards

```typescript
interface CardImpactInput {
  /** project scope */
  projectId: string;
  /** Workspace scope when including code in traversal (optional) */
  workspaceId?: string;
  cardKey: string;
  maxDepth?: number;
}

interface CardImpactResult {
  cardKey: string;
  depth: number;
  truncated: boolean;
  impactedCode: Array<{ entityKey: string; identityId: number; path: string[] }>;
  impactedCards: Array<{ cardKey: string; identityId: number; relationType: string; path: string[] }>;
  summary: { totalImpacted: number; codeCount: number; cardCount: number };
}
```

**Bidirectional BFS implementation SQL example**:

```sql
WITH RECURSIVE
contains_type AS (
  SELECT id FROM relation_type_registry WHERE domain = 'card_relation' AND key = 'contains'
),
depends_type AS (
  SELECT id FROM relation_type_registry WHERE domain = 'card_relation' AND key = 'depends_on'
),
-- Forward: children (contains) + dependents (reverse of depends_on)
forward_bfs AS (
  SELECT :card_identity_id::int AS id, 0 AS depth, 'root'::text AS rel_type, ARRAY[:card_identity_id] AS path
  UNION ALL
  SELECT
    CASE
      WHEN cr.relation_type_id = (SELECT id FROM contains_type) THEN cr.dst_identity_id
      WHEN cr.relation_type_id = (SELECT id FROM depends_type) THEN cr.src_identity_id
    END,
    fb.depth + 1,
    rtr.key,
    fb.path || CASE
      WHEN cr.relation_type_id = (SELECT id FROM contains_type) THEN cr.dst_identity_id
      ELSE cr.src_identity_id
    END
  FROM card_relation cr
  JOIN forward_bfs fb ON (
    (cr.src_identity_id = fb.id AND cr.relation_type_id = (SELECT id FROM contains_type))
    OR
    (cr.dst_identity_id = fb.id AND cr.relation_type_id = (SELECT id FROM depends_type))
  )
  JOIN relation_type_registry rtr ON rtr.id = cr.relation_type_id
  WHERE fb.depth < :max_depth
),
-- Reverse: linked code entities
impacted_code AS (
  SELECT cl.code_identity_id, ev.entity_key, fb.path
  FROM forward_bfs fb
  JOIN card_link cl ON cl.card_identity_id = fb.id
    AND cl.project_id = :project_id
  JOIN entity_version ev ON ev.identity_id = cl.code_identity_id AND ev.status = 'active'
)
SELECT * FROM forward_bfs
UNION ALL
SELECT code_identity_id, -1, 'code_link', path FROM impacted_code;
```

#### `card_dashboard` (v4.2 E-2: renamed from `card_status` to avoid confusion with `entity_version.card_status` column)

Health status of the entire KB or a specific card.

```typescript
interface CardDashboardResult {
  scope:
    | { level: 'global' }
    | { level: 'project'; projectId: string }
    | { level: 'workspace'; projectId: string; workspaceId: string };
  cards: {
    total: number;
    byStatus: Record<CardStatus, number>;
    byPriority: Record<CardPriority, number>;
  };
  coverage: {
    percent: number;
    byCard: Array<{
      cardKey: string;
      totalChildren: number;
      /** v4.7 F-10: Number of children with fresh link + active evidence (same criteria as ¬ß7.1 coverage definition) */
      coveredChildren: number;
      coveragePercent: number;
      weight: number;
    }>;
  };
  links: {
    total: number;
    fresh: number;
    staleCandidate: number;
    staleConfirmed: number;
  };
  recentActivity: {
    approvalEventsLast7d: number;
    lastSyncRun: string | null;
  };
}
```

#### `coverage_map`

Recursively calculates subtree coverage for a specific card and returns it in tree format.

```typescript
interface CoverageMapInput {
  projectId: string;
  workspaceId?: string;
  rootCardKey: string;
  maxDepth?: number;
}
```

### 12.3 Governance Tools

- `rollback_approval`: Restore previous state via compensating action (see ¬ß8.5)
- `resolve_identity_candidates`: Present identity reconnection candidates from archived versions (see ¬ß9.3)
- `apply_identity_rewrite`: Change card_link's code_identity_id to reconnect identity after user approval (see ¬ß9.3)

### 12.4 Per-Tool Bulk Support

```typescript
interface RegisterCardBatchInput {
  cards: RegisterCardInput[];
}
```

> Batch register multiple cards in a single transaction. Full rollback on failure.

### 12.5 Existing Tool Changes

All 18 existing tools converted to identity + active version JOIN-based queries.

Additional changes:

#### `search` (card-aware search)

```typescript
interface SearchInput {
  projectId: string;
  workspaceId?: string;
  /** Search query (FTS applied) */
  query: string;
  /** Filter conditions (optional) */
  filters?: {
    entityTypes?: ('card' | 'module' | 'symbol')[];
    cardStatus?: CardStatus[];
    cardPriority?: CardPriority[];
    cardTags?: string[];
    /** If true, exclude deprecated (default: true) */
    excludeDeprecated?: boolean;
  };
  /** Sort criteria */
  orderBy?: 'relevance' | 'created_at' | 'card_priority';
  limit?: number;
  offset?: number;
}

interface SearchResult {
  items: Array<{
    identityId: number;
    entityKey: string;
    entityType: string;
    summary: string | null;
    cardStatus?: CardStatus;
    cardPriority?: CardPriority;
    cardTags?: string[];
    /** FTS rank score */
    rank: number;
  }>;
  total: number;
  hasMore: boolean;
}
```

> Internal implementation uses `ts_rank()` based search with `entity_version.search_tsv`. Filters are combined as WHERE conditions.

- `inconsistency_report`: Added card-specific checks (¬ß10.4 stale link, orphan card, **card_key path mismatch** (v4.4 P-7))
  > **card_key path mismatch check** (v4.4 P-7): Detects cards where the card_key path and actual parent (contains in card_relation) are inconsistent after `move_card`. Example: key is `card::auth/login` but actual parent is `card::billing` ‚Üí mismatch. Reported at warning level (non-blocking).
- `find_orphans`: Added check for "non-root cards without a parent"

### 12.6 Agent Context Retrieval Tools (Consumer Tools)

> **Core motivation**: bunner-kb is a "vibe-coding RAG server". CRUD/management tools from ¬ß12.1~12.5 alone are insufficient for agents to extract context from the KB during coding. The tools in this section are **read-only consumer tools** for agents to quickly obtain minimal context **during actual coding work**.

#### `get_context`

Returns cards, relations, and evidence related to a specific file/code in bulk. Recommended for automatic invocation when an agent opens a file.

```typescript
interface GetContextInput {
  projectId: string;
  workspaceId: string;
  /** File path or entity_key. Interpretation rules (v4.2 C-3):
   * - "module:" or "symbol:" prefix ‚Üí interpreted as entity_key
   * - "card::" prefix ‚Üí interpreted as card entity_key (returns linked code of the card)
   * - Otherwise ‚Üí interpreted as file path. Converted to "module:{target}" then queried
   */
  target: string;
  /** Scope of returned information (default: 'full') */
  depth?: 'minimal' | 'standard' | 'full';
}

interface GetContextResult {
  /** Target code entity information */
  codeEntity: {
    identityId: number;
    entityKey: string;
    summary: string | null;
    contentHash: string | null;
  } | null;
  /** Linked card list (via card_link) */
  linkedCards: Array<{
    cardKey: string;
    summary: string;
    cardStatus: CardStatus;
    cardPriority: CardPriority | null;
    rationale: string;
    staleStatus: string;
    /** Included only when depth='full' */
    body?: string;
    acceptanceCriteria?: AcceptanceCriterion[];
  }>;
  /** Related code entities (via code_relation) */
  relatedCode: Array<{
    entityKey: string;
    relationType: string;
    direction: 'outgoing' | 'incoming';
  }>;
  /** When depth='full': parent/child cards of linked cards */
  cardContext?: Array<{
    cardKey: string;
    parentCardKey: string | null;
    childCardKeys: string[];
    dependsOn: string[];
    dependedBy: string[];
  }>;
}
```

#### `get_implementation_guide`

Returns reference information for implementing a specific card (related code, dependencies, sibling cards).

```typescript
interface GetImplementationGuideInput {
  projectId: string;
  workspaceId: string;
  cardKey: string;
}

interface GetImplementationGuideResult {
  card: {
    cardKey: string;
    summary: string;
    body: string;
    cardStatus: CardStatus;
    cardPriority: CardPriority | null;
    acceptanceCriteria: AcceptanceCriterion[];
  };
  /** Already linked code entities */
  existingLinks: Array<{
    entityKey: string;
    filePath: string;
    rationale: string;
    staleStatus: string;
  }>;
  /** Dependent cards and their implementation status */
  dependencies: Array<{
    cardKey: string;
    summary: string;
    cardStatus: CardStatus;
    linkedCodeCount: number;
  }>;
  /** Sibling cards under the same parent */
  siblings: Array<{
    cardKey: string;
    summary: string;
    cardStatus: CardStatus;
  }>;
  /** Parent card information */
  parent: {
    cardKey: string;
    summary: string;
  } | null;
  /** Implementation progress */
  coverage: {
    totalChildren: number;
    linkedChildren: number;
    coveragePercent: number;
  };
}
```

#### `get_subgraph`

Extracts an N-hop subgraph centered on a specific entity. For visualization/exploration.

```typescript
interface GetSubgraphInput {
  projectId: string;
  workspaceId?: string;
  /** Center entity's identity_id or entity_key */
  center: number | string;
  /** Traversal depth (default: 2) */
  hops?: number;
  /** Relation types to include (default: all) */
  includeRelationTypes?: string[];
  /** Whether to include card_links (default: true) */
  includeCardLinks?: boolean;
}

interface GetSubgraphResult {
  nodes: Array<{
    identityId: number;
    entityKey: string;
    entityType: string;
    summary: string | null;
    cardStatus?: CardStatus;
    cardPriority?: CardPriority;
  }>;
  edges: Array<{
    sourceId: number;
    targetId: number;
    relationType: string;
    table: 'card_link' | 'card_relation' | 'code_relation';
    meta?: Record<string, unknown>;
  }>;
  center: number;
  truncated: boolean;
}
```

> **Performance targets**: `get_context` < 50ms, `get_implementation_guide` < 100ms, `get_subgraph(hops=2)` < 200ms.

### 12.7 Agent Workflow Guide (v4.4 P-6, S-3)

Defines **in what order and under what circumstances** agents (AI) use bunner-kb MCP tools. This section integrates with MCP usage rules in `AGENTS.md` and `.cursor/rules/`.

#### Core Principles

1. **Read-before-Write**: Before modifying code, always check related card/link status via `get_context` or `search`
2. **Card-first Flow**: Cards must be registered before implementation. Writing code without a card is "untraceable implementation" from the KB perspective
3. **Evidence creation obligation**: After writing/modifying code, create card_link + evidence via `link_card`

#### Workflow A: New Feature Implementation

```
1. register_card        ‚Äî Define requirements (user instruction or agent judgment)
2. get_implementation_guide ‚Äî Check implementation guide (sibling cards, parent, coverage status)
3. [Write code]          ‚Äî Agent generates/modifies code
4. link_card            ‚Äî Link written code to card (evidence auto-created)
5. update_card_status   ‚Äî implementing ‚Üí implemented (on completion)
6. coverage_map         ‚Äî Check progress (optional)
```

#### Workflow B: Modify Existing Code

```
1. get_context          ‚Äî Check related cards of file/code to modify
2. card_dashboard       ‚Äî Check stale links, overall status (optional)
3. [Modify code]        ‚Äî Modify with reference to card body
4. link_card            ‚Äî Re-verify link of modified code (stale ‚Üí fresh)
```

#### Workflow C: Refactoring (File Move/Rename)

```
1. get_context          ‚Äî Check card_links of target file to move
2. [Move/rename file]   ‚Äî Agent performs refactoring
3. [startupScan/watch]  ‚Äî Sync Worker auto identity matching (Tier 1)
4. get_context          ‚Äî Verify link preservation after move
5. resolve_identity_candidates ‚Äî Review candidates if auto-matching fails (Tier 2)
```

#### Workflow D: Card Management (User-driven)

```
1. register_card        ‚Äî Register/modify card
2. relate_cards         ‚Äî Set card relationships (depends_on, extends, etc.)
3. update_card_status   ‚Äî Lifecycle transition (draft ‚Üí proposed ‚Üí accepted ‚Üí ...)
4. card_impact          ‚Äî Check impact scope on state change (optional)
```

#### AGENTS.md / .cursor/rules Integration (v4.4 S-3)

For agents to automatically follow these workflows, the following must be reflected in `AGENTS.md` or `.cursor/rules/mcp-usage.mdc`:

| Rule | AGENTS.md / rules Content |
|------|---------------------------|
| Read-before-Write | "Must call `get_context` before code changes" |
| Card-first | "Check if card is registered before implementing new features. If not, run `register_card` first" |
| Evidence obligation | "After writing/modifying code, call `link_card` to create card_link + evidence" |
| Stale handling | "After modifying card body, check stale links via `card_dashboard`, re-call `link_card` if needed" |
| Workspace verification | "Use workspace_id corresponding to current branch for MCP calls. No writes to archived workspaces" |

> **Implementation timing**: These rules will be reflected in `AGENTS.md` and `.cursor/rules/mcp-usage.mdc` after v4 MCP tools are implemented. Since tool names/parameters differ from existing tools, rules will be batch-updated when v4 tool implementation is complete.

---

## 13. Error and Exception Handling

> In v4, core card attributes are normalized into `entity_version.card_*` columns. (e.g.: `card_status`, `card_priority`, `card_weight`, `card_tags`)
> Therefore tool input validation uses both (1) schema enum/range constraints and (2) application-level validation.

### 13.1 `register_card` Errors

| Validation | Rule | Error Message |
|------|------|-------------|
| `cardKey` prefix | Must start with `card::` | "cardKey must start with 'card::'" |
| `cardKey` format | Regex validation | "cardKey must be 'card::{path}' with kebab-case segments" |
| `parentCardKey` | card entity must exist | "Parent card not found: {key}" |
| Cycle check | Cannot set self as parent | "Cannot set self as parent" |
| `status` | Valid CardStatus | "Invalid status" |
| `priority` | P0~P3 or null | "Invalid priority" |
| `weight` | 0.0 ~ 1.0 | "weight must be between 0.0 and 1.0" |
| `projectId` | Required | "projectId is required" |

### 13.2 `link_card` Errors

| Situation | Handling |
|------|------|
| No active version for code entity | Error + recommend similar entities via search |
| Card identity not found | Error: "Card not found. Use register_card first." |
| card status = 'deprecated' | Error: "Cannot link to deprecated card" |
| project/workspace mismatch | Error: "Workspace does not belong to project" |
| Identical link already exists | upsert: update meta, `link_updated` |

### 13.3 `update_card_status` Errors

| Situation | Handling |
|------|------|
| Invalid transition | Error: "Cannot transition from {from} to {to}" |
| Upper-bound warning (v4.2 F-2) | Warning: "Child status exceeds parent status" (transition allowed, included in response `warnings[]`) |
| Evidence unmet on verified transition (v4.2 C-1) | Error: "No active evidence found. Link code to this card first." |
| `projectId` mismatch | Error: "Card not found in project" |

### 13.4 `@card` Parsing Errors (v4.2 C-4)

Errors from `@card` annotation parsing in sync worker are defined in ¬ß10.1. Do not abort sync; recorded as warnings in `sync_event`.

### 13.5 Other Errors

Error handling for identity matching, apply_identity_rewrite, rollback_approval, etc.:

---

## 14. Schema Change Details

### 14.1 New Tables

| Table | Purpose |
|--------|------|
| `tenant` | Multi-tenancy boundary (¬ß2.7) |
| `project` | SSOT boundary for card knowledge (¬ß2.7) |
| `workspace` | Code indexing unit (= project + branch) (¬ß2.7) |
| `entity_identity` | Immutable identity (¬ß3.3) |
| `entity_version` | Mutable address/state (¬ß3.3) |
| `entity_lifecycle` | Lifecycle event log (¬ß3.3) |
| `approval_event` | Governance events (¬ß8.2) |
| `relation_type_registry` | Relation type registry (¬ß5.1) |
| `card_link` | card‚Üîcode connection (¬ß5.2) |
| `card_relation` | card‚Üîcard relationship (¬ß5.3) |
| `code_relation` | code‚Üîcode relationship (¬ß5.4) |
| `card_evidence` | Polymorphic evidence (¬ß6.1) |

### 14.2 Modified Tables

| Table | Change |
|--------|-----------|
| `source` | `entity_id` ‚Üí `version_id` (FK target changed) |
| `fact` | `entity_id` ‚Üí `version_id` (FK target changed) |
| `sync_event` | `entity_id` ‚Üí `identity_id` + `version_id` |

> `source`, `fact`, `fact_type`, `strength_type` DDL are defined in ¬ß3.3. During migration, FK targets are changed from `entity_id` ‚Üí `version_id`.

#### `sync_event` (v4 DDL)

```sql
CREATE TABLE sync_event (
  id            SERIAL PRIMARY KEY,
  sync_run_id   INTEGER NOT NULL REFERENCES sync_run(id),
  identity_id   INTEGER REFERENCES entity_identity(id) ON DELETE SET NULL,
  version_id    INTEGER REFERENCES entity_version(id) ON DELETE SET NULL,
  action        TEXT NOT NULL CHECK (action IN ('created', 'updated', 'archived', 'deleted', 'matched')),
  entity_key    TEXT,
  meta          JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX sync_event_run_idx ON sync_event(sync_run_id);
CREATE INDEX sync_event_identity_idx ON sync_event(identity_id);
```

### 14.3 Removed Tables

| Table | Timing |
|--------|------|
| `entity` | Removed after migration complete |
| `relation` | Removed after split into `card_link` + `card_relation` + `code_relation` |
| `relation_evidence` | Removed after replaced by `card_evidence` |

### 14.4 Seed Data

```sql
-- entity_type seed (fixed ids ‚Äî directly referenced by other DDLs) (v4.2 F-4)
INSERT INTO entity_type (id, name) VALUES
  (1, 'module'),
  (2, 'symbol'),
  (3, 'card')
ON CONFLICT (id) DO NOTHING;
SELECT setval('entity_type_id_seq', (SELECT MAX(id) FROM entity_type));

-- relation_type_registry seed (fixed ids ‚Äî partial unique index references id=1) (v4.2 F-4)
INSERT INTO relation_type_registry (id, domain, key, description, is_system) VALUES
  -- card_relation types
  (1, 'card_relation', 'contains',   'parent ‚Üí child (nested tree edge)', true),
  (2, 'card_relation', 'depends_on', 'A depends on B (DAG)', true),
  (3, 'card_relation', 'extends',    'A extends B (cycle allowed)', true),
  -- code_relation types (v4.2 E-3: 'implements' is a code‚Üîcode interface implementation relation.
  --   Different from v1's spec‚Üîcode 'implements' relation ‚Äî v1's was migrated to card_link. See ¬ß15.3)
  (4, 'code_relation', 'imports',    'module import', true),
  (5, 'code_relation', 'extends',    'class/interface inheritance', true),
  (6, 'code_relation', 'calls',      'function call', true),
  (7, 'code_relation', 'implements', 'interface implementation (code‚Üîcode only)', true)
ON CONFLICT (id) DO NOTHING;
SELECT setval('relation_type_registry_id_seq', (SELECT MAX(id) FROM relation_type_registry));

-- fact_type seed (fixed ids)
INSERT INTO fact_type (id, name) VALUES
  (1, 'module_info'),
  (2, 'symbol_info'),
  (3, 'card_body')
ON CONFLICT (id) DO NOTHING;
SELECT setval('fact_type_id_seq', (SELECT MAX(id) FROM fact_type));

-- strength_type seed (fixed ids)
INSERT INTO strength_type (id, name) VALUES
  (1, 'inferred'),
  (2, 'manual'),
  (3, 'derived')
ON CONFLICT (id) DO NOTHING;
SELECT setval('strength_type_id_seq', (SELECT MAX(id) FROM strength_type));

-- system user seed (v4.3 B-1) ‚Äî for system operations such as migration, sync
INSERT INTO "user" (id, email) VALUES
  ('migration', 'system+migration@bunner.local'),
  ('system',    'system@bunner.local')
ON CONFLICT (id) DO NOTHING;
```

> Previously used `spec`, `claim` entity_types are removed after migration complete.
> User-defined relation types are added with `is_system = false`.
> **(v4.2 F-4)**: Fixed seed ids for safe reference in partial unique indexes (`card_relation_single_parent WHERE relation_type_id = 1`), etc. Sequence sync via `setval`.
> **(v4.3 B-1, v4.7 F-2)**: `migration` user is used for card_link.created_by in migration scripts. `system` user is dedicated to internal system operations like schedulers and purge jobs. **No `system` fallback when `user_id` is not set** ‚Äî per ¬ß2.7 policy, the MCP server refuses to start when `user_id` is not configured.

### 14.5 Performance Baseline

Performance targets for key queries:

| Query | Target Response Time | Notes |
|------|--------------|------|
| `resolveIdentity` (stable_key) | < 5ms | `project_id + stable_key` partial unique index |
| `resolveIdentity` (entity_key) | < 10ms | Active unique index per scope (project/workspace) |
| card_link stale list | < 50ms | partial index on stale_status |
| coverage_map (depth 5) | < 200ms | recursive CTE + index |
| card_impact (depth 3) | < 100ms | BFS + index |

### 14.6 FTS Dependency (v4.2 D-6 baseline strategy finalized)

**Baseline strategy: `pg_bigm` (finalized)**

Since writing card body in Korean is natural in vibe-coding, Korean FTS is **mandatory in v4 scope**. PostgreSQL's built-in `'simple'` config only tokenizes by whitespace and is effectively useless for Korean.

| Option | Installation | Korean | Selection |
|------|------|--------|------|
| `pg_bigm` | 1-line Docker extension | Bigram-based. 2+ character matching | ‚úÖ **v4 default** |
| `pgroonga` | Separate Groonga install | High accuracy | v3.1 option |
| Built-in `simple` | None | Whitespace-only | ‚ùå Korean unsupported |

> Include `pg_bigm` extension installation in `docker-compose.yml`. Consider switching to `pgroonga` in v3.1 when higher accuracy is needed.

### 14.7 Search (FTS) / Vector (pgvector) Preparation

v4 **does not create additional VIEW/TABLE**, instead providing the "Graph Read Model (queryable data format)" by placing search/vector columns on the SSOT table (`entity_version`).

#### FTS (PostgreSQL built-in)

```sql
-- pg_bigm-based FTS (v4.2 D-6)
-- pg_bigm accelerates LIKE '%query%' via GIN index
CREATE INDEX entity_version_search_bigm_entity_key_idx
  ON entity_version USING gin (entity_key gin_bigm_ops)
  WHERE status = 'active';

CREATE INDEX entity_version_search_bigm_summary_idx
  ON entity_version USING gin (summary gin_bigm_ops)
  WHERE status = 'active' AND summary IS NOT NULL;

CREATE INDEX entity_version_search_bigm_card_body_idx
  ON entity_version USING gin (card_body gin_bigm_ops)
  WHERE status = 'active' AND card_body IS NOT NULL;
```

> **Dual-index strategy** (v4.7 F-1): Search operates in two stages:
> 1. **Candidate filtering** (pg_bigm): `WHERE entity_key LIKE '%query%' OR summary LIKE '%query%' OR card_body LIKE '%query%'`. pg_bigm GIN index accelerates Korean bigram matching.
> 2. **Result ranking** (search_tsv): `ORDER BY ts_rank(search_tsv, query)`. Ranks by accuracy with entity_key(A) > summary(B) > card_body(C) weighting.
>
> **Fallback**: Without pg_bigm, search uses only `to_tsvector('simple', ...)` from search_tsv. In this case, Korean partial matching quality degrades significantly (whitespace-based tokenization only).
>
> SSOT remains `entity_version` as-is. No separate search tables/VIEWs are created.

#### Vector (pgvector hook)

```sql
-- Dimension is determined by model/embedding policy
-- ALTER TABLE entity_version ADD COLUMN embedding vector(<dim>);
-- CREATE INDEX entity_version_embedding_hnsw_idx ON entity_version USING hnsw (embedding vector_cosine_ops);
```

---

## 15. Migration Path (Current ‚Üí v4)

### 15.1 Strategy

Direct migration from the current schema to v4.

| Phase | Content |
|-------|------|
| 1 | Create new tables (including `"user"`, add `status`/`updated_at` to workspace) (v4.3) |
| 2 | entity ‚Üí entity_identity + entity_version data copy (INSERT...RETURNING approach) |
| 3 | relation ‚Üí card_link + card_relation + code_relation split |
| 4 | source/fact FK conversion |
| 5 | Legacy table removal |

### 15.2 Phase 2: Entity Mapping

> Safe 1:1 mapping via `INSERT...RETURNING` (prevents ROW_NUMBER matching instability).

```sql
-- (v4.2 A-4) Create mapping temp table (missing in v4.1)
CREATE TEMP TABLE entity_to_identity_map (
  entity_id   INTEGER NOT NULL,
  identity_id INTEGER NOT NULL,
  entity_key  TEXT NOT NULL,
  workspace_id TEXT,
  PRIMARY KEY (entity_id)
);

-- Safe 1:1 mapping via PL/pgSQL loop (v4.2 A-4: resolves non-unique matching issue of CTE JOIN)
DO $$
DECLARE
  rec RECORD;
  new_identity_id INTEGER;
  card_type_id SMALLINT;
BEGIN
  SELECT id INTO card_type_id FROM entity_type WHERE name = 'card';

  FOR rec IN
    SELECT e.id AS entity_id, e.entity_key, e.workspace_id, e.created_at,
           et.name AS type_name, et.id AS type_id,
           w.project_id
    FROM entity e
    JOIN entity_type et ON et.id = e.entity_type_id
    JOIN workspace w ON w.id = e.workspace_id
    ORDER BY e.id
  LOOP
    INSERT INTO entity_identity (
      project_id, workspace_id, entity_type_id, stable_key, created_at
    ) VALUES (
      rec.project_id,
      CASE WHEN rec.type_name IN ('spec', 'claim') THEN NULL ELSE rec.workspace_id END,
      CASE WHEN rec.type_name IN ('spec', 'claim') THEN card_type_id ELSE rec.type_id END,
      CASE
        WHEN rec.type_name = 'spec' THEN REPLACE(rec.entity_key, 'spec::', 'card::')
        WHEN rec.type_name = 'claim' THEN REPLACE(rec.entity_key, 'claim::', 'card::')
        ELSE NULL
      END,
      rec.created_at
    ) RETURNING id INTO new_identity_id;

    INSERT INTO entity_to_identity_map (entity_id, identity_id, entity_key, workspace_id)
    VALUES (rec.entity_id, new_identity_id, rec.entity_key, rec.workspace_id);
  END LOOP;
END $$;
```

> **Verification**: entity count == identity count == map count. Abort immediately on mismatch.
> **(v4.2 A-4)**: v4.1's CTE + JOIN approach could produce duplicate matching via non-unique `workspace_id + created_at` joins. Changed to PL/pgSQL loop to guarantee exact 1:1 mapping via INSERT ‚Üí RETURNING for each entity.

### 15.3 Phase 3: relation Split

The v1 `relation` table is split into v4's 3 tables.

#### Step 1: Existing relation_type ‚Üí v4 registry mapping

```sql
-- Map existing relation_type table names to v4 registry
-- Create mapping temp table
CREATE TEMP TABLE relation_type_map AS
SELECT
  v1rt.id AS v1_type_id,
  v1rt.name AS v1_name,
  v4rtr.id AS v4_registry_id,
  v4rtr.domain AS v4_domain
FROM relation_type v1rt  -- existing table
JOIN relation_type_registry v4rtr ON (
  -- Existing name ‚Üí v4 (domain, key) mapping
  -- (v4.2 E-3, v4.7 F-5) Existing 'implements' is a spec‚Üîcode relation, so it's migrated to card_link (Step 2a).
  -- This mapping table only includes code_relation types. implements is handled via a separate path.
  (v1rt.name = 'imports' AND v4rtr.domain = 'code_relation' AND v4rtr.key = 'imports')
  OR (v1rt.name = 'extends' AND v4rtr.domain = 'code_relation' AND v4rtr.key = 'extends')
  OR (v1rt.name = 'calls' AND v4rtr.domain = 'code_relation' AND v4rtr.key = 'calls')
  -- Add additional existing type mappings here
);

-- Mapping verification: confirm all relation_types are mapped except implements
-- (implements is separately migrated to card_link in Step 2a)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM relation_type v1rt
    WHERE v1rt.name != 'implements'
      AND NOT EXISTS (SELECT 1 FROM relation_type_map rtm WHERE rtm.v1_type_id = v1rt.id)
  ) THEN
    RAISE EXCEPTION 'Unmapped relation types exist (excluding implements). Migration aborted.';
  END IF;
END $$;
```

#### Step 2: relation ‚Üí card_link / card_relation / code_relation split

```sql
-- (a) spec/claim related relation ‚Üí card_link
-- Where v1 strength='manual' and one side is spec/claim, the other is code
INSERT INTO card_link (
  project_id, workspace_id,
  card_identity_id, code_identity_id,
  anchor, rationale, weight, created_by, stale_status,
  created_at, updated_at
)
SELECT
  p.id,
  w.id,
  m_card.identity_id,
  m_code.identity_id,
  '{}'::jsonb,  -- anchor does not exist in v1, so empty object
  'Migrated from relation #' || r.id,
  1.0,
  'migration',  -- v4.3: migration-dedicated user (pre-created in seed)
  'fresh',
  r.created_at,
  r.created_at
FROM relation r
JOIN entity_to_identity_map m_card ON m_card.entity_id = r.src_entity_id
JOIN entity_to_identity_map m_code ON m_code.entity_id = r.dst_entity_id
JOIN entity e_src ON e_src.id = r.src_entity_id
JOIN entity_type et_src ON et_src.id = e_src.entity_type_id
JOIN workspace w ON w.id = e_src.workspace_id
JOIN project p ON p.id = w.project_id
WHERE et_src.name IN ('spec', 'claim')
ON CONFLICT (card_identity_id, code_identity_id) DO NOTHING;

-- (b) code‚Üîcode relation ‚Üí code_relation
INSERT INTO code_relation (
  workspace_id,
  src_identity_id, dst_identity_id,
  relation_type_id, strength, source_file,
  created_at
)
SELECT
  e_src.workspace_id,
  m_src.identity_id,
  m_dst.identity_id,
  rtm.v4_registry_id,
  r.strength,
  NULL,
  r.created_at
FROM relation r
JOIN relation_type_map rtm ON rtm.v1_type_id = r.relation_type_id
  AND rtm.v4_domain = 'code_relation'
JOIN entity_to_identity_map m_src ON m_src.entity_id = r.src_entity_id
JOIN entity_to_identity_map m_dst ON m_dst.entity_id = r.dst_entity_id
JOIN entity e_src ON e_src.id = r.src_entity_id
ON CONFLICT (src_identity_id, dst_identity_id, relation_type_id) DO NOTHING;
```

> **Verification** (v4.7 F-5): `COUNT(relation)` == `COUNT(card_link migrated from Step 2a)` + `COUNT(code_relation migrated from Step 2b)`. implements relations are distributed to card_link in Step 2a, the rest (imports/extends/calls) to code_relation in Step 2b. Abort on mismatch.

### 15.4 Rollback Plan

Each phase executes as an individual transaction. Verification checkpoints between phases.

### 15.5 Dual-Write / Dual-Read

Gradual transition from current ‚Üí v4 via `BUNNER_V4_ENABLED` feature flag.

---

## 16. Implementation Order

### 16.1 Step-by-Step Work

| Step | Work | Dependencies | Risk |
|------|------|--------|--------|
| **0** | Preflight: Establish regression test baseline | None | Low |
| **1** | v4 schema creation (identity, version, lifecycle, approval_event, relation_type_registry, card_link, card_relation, code_relation, card_evidence) | None | Low |
| **2** | Migration script (INSERT...RETURNING + relation split) + verification | 1 | **High** |
| **3** | Repo layer separation (identity-repo, version-repo, card-link-repo, card-relation-repo) | 2 | High |
| **3b** | Dual-read adapter | 3 | Medium |
| **4** | Card tool implementation (register_card, link_card, unlink_card, move_card, update_card_status, relate_cards, unrelate_cards) | 3b | Medium |
| **5** | Governance tools (rollback_approval + payload validation) | 4 | Medium |
| **6** | Analysis tools (card_impact, card_dashboard, coverage_map) | 4 | Medium |
| **6b** | Agent Context tools (get_context, get_implementation_guide, get_subgraph) | 4 | Medium |
| **7** | Sync worker rewrite (version append + @card parsing + stale detection) | 3b | **High** |
| **8** | Purge rewrite (lifecycle FK handling + COALESCE identity purge) | 7 | High |
| **9** | Identity resolution (resolve_identity_candidates + apply_identity_rewrite) | 4 | Medium |
| **10** | Existing 18 tool query conversion | 3b | High |
| **11** | Compatibility mode termination + legacy removal | 10 complete + verification | **High** |

### 16.2 Compatibility Mode

Gradual transition via `BUNNER_V4_ENABLED` feature flag. When flag is off, use existing tools/queries; when on, switch to v4 tools/queries.

---

## 17. Future Extension Paths

### 17.1 In-code @card Annotation Tags

`/** @card card::auth/login */` parser recognition ‚Üí auto `card_link` creation. `evidence_type: 'annotation'`.

### 17.2 Card ‚Üí Code Glob Pattern (v3.1)

`implementsPattern: "src/auth/**"` in card.meta ‚Üí auto matching.

### 17.3 Test Evidence Auto-collection (v3.1)

CI result integration. Auto-generation of `evidence_type: 'test_pass'`.

### 17.4 AI Verification (v3.1)

LLM verifies code‚Üîcard alignment. `evidence_type: 'ai_verification'`.

### 17.5 Tree Snapshot / Baseline (v3.1)

Save card tree + coverage state as a snapshot at a specific point in time. Timeline trend graphs.

### 17.6 Advisory Lock (v3.1)

Identity-level locking via `pg_advisory_xact_lock(identity_id)`. Replaces ¬ß9.4's SERIALIZABLE defense with fine-grained locking to improve concurrency.

### 17.7 `.card.md` Parser (v3.1)

Sync parser recognizes `.card.md` files and auto-registers cards.

### 17.8 approval_event Archive Policy (v3.1)

Migrate old approval_events to a separate archive table to maintain main table performance. Migration criteria: `created_at < now() - {archiveDays} * interval '1 day'`.

### 17.9 Weighted Scoring for Identity Candidates (v3.1)

Refine candidate ranking during identity resolution by assigning weighted scores for `symbolName` similarity, `summary` similarity, etc., in addition to content_hash.

### 17.10 Cross-project Card Sharing (v3.2)

Reference common cards across multiple projects. Minimum interface design direction:

```typescript
// v3.2 interface draft ‚Äî not implemented in v4, but direction defined in advance to prevent schema breakage on extension
interface SharedCardRef {
  /** Original card's project */
  sourceProjectId: string;
  /** Original card identity */
  sourceCardIdentityId: number;
  /** Referencing project */
  targetProjectId: string;
  /** Reference type: 'mirror' (read-only copy) | 'alias' (direct original reference) */
  refType: 'mirror' | 'alias';
}
```

> **v4 scope constraint**: `card_relation`/`card_link` are single `project_id` scope, so cross-project references require a separate `shared_card_ref` table. This table is not created in v4, but `entity_identity.project_id` is maintained as FK to minimize schema changes on future extension.

### 17.11 Access Control / Ownership (v3.2)

Card owner/reviewer assignment.

### 17.12 Knowledge Quality Scoring / Decay (v3.1)

Time-based evaluation of card and link quality, with automatic confidence decay for old/unverified knowledge:

| Metric | Calculation | Purpose |
|------|----------|------|
| freshness | `1.0 - (now - verified_at) / decay_window` | Stale link prioritization |
| evidence_quality | `Œ£(evidence_weight √ó is_active)` | Card confidence |
| coverage_quality | `coverage √ó avg(link_freshness)` | Effective implementation progress |

> Schema hook: `card_link.verified_at`, `card_evidence.is_active` already exist so no additional columns needed. Calculations performed at query time.

### 17.13 Temporal Query (v3.1)

Support time-based questions like "What was coverage 2 weeks ago?" or "Status change trend for this card":

- **Method 1**: Reconstruct state at a specific point in time based on `entity_lifecycle` + `approval_event`'s `created_at`
- **Method 2**: Combine with Tree Snapshot (¬ß17.5) for point-in-time snapshot comparison
- Schema hook: `entity_version.created_at`, `approval_event.created_at` already hold timestamps

### 17.14 Event Stream (Webhook / Push) (v3.2)

Push KB changes to external systems:

| Event | Target |
|--------|------|
| `card_link.stale_status` change | IDE notification, Slack |
| card status transition | Project dashboard |
| Coverage threshold reached | CI/CD pipeline |

> Schema hook: Since `approval_event` is the SSOT for all state transitions, event streams can be implemented via approval_event INSERT triggers.

### 17.15 Export / Import (Portability) (v3.2)

Export/import project KB in a portable format:

```typescript
interface KBExportFormat {
  version: 'v4';
  project: { id: string; name: string };
  cards: Array<{ cardKey: string; body: string; status: CardStatus; /* ... */ }>;
  cardRelations: Array<{ src: string; dst: string; type: string }>;
  cardLinks: Array<{ cardKey: string; codeEntityKey: string; rationale: string; /* ... */ }>;
  evidence: Array<{ cardLinkKey: string; type: string; snapshot: unknown }>;
}
```

### 17.16 Training Data Extraction Pipeline (v3.2)

Extract accumulated KB knowledge (card ‚Üî code mappings, evidence, approval patterns) as agent training data:

- card body + linked code ‚Üí fine-tuning dataset
- approval_event patterns ‚Üí agent decision-making improvement
- stale ‚Üí fresh transition history ‚Üí link quality prediction model

> Schema hook: All data is normalized in PostgreSQL, so extraction via SQL-based ETL is possible.

### 17.17 Natural Language Query Interface (v3.2)

Agents or users query the KB in natural language:

```typescript
interface NaturalLanguageQueryInput {
  projectId: string;
  question: string;  // "What are the unimplemented cards in the auth module?"
}
```

> Implementation path: pgvector embedding (¬ß14.7) + LLM SQL generation or entity_version.search_tsv FTS + post-processing.

---

## Appendix A: Glossary

| Term | Definition |
|------|------|
| **tenant** | Deployment/organization boundary. Top-level scope grouping multiple projects (¬ß2.7) |
| **project** | SSOT boundary for card knowledge. Default scope for card/card_relation/approval_event (¬ß2.7) |
| **workspace** | Code indexing unit (= project + branch). Scope for code/code_relation. Append-only ‚Äî archived, not deleted (¬ß2.7, ¬ß11.4) |
| **user** | Actor identification table. `"user"` (PG reserved word). Referenced by actor_id of all write operations (¬ß2.7) |
| **card** | First-class knowledge object. Node of a nested tree expressing requirements/feature specs. Single entity_type forming unlimited-depth trees |
| **entity_identity** | Immutable identity throughout an entity's lifetime. The target referenced by card_link/code_relation |
| **entity_version** | An entity's state at a specific point in time (address, content, meta). Mutable |
| **entity_key** | Current address stored in entity_version. Format: `{type}:{identifier}` |
| **stable_key** | Immutable identifier for card entities. Format: `card::{path}` |
| **identity matching** | Process of linking a new version to an existing identity using content_hash |
| **approval_event** | First-class event recording manual/semi-auto state transitions. Single source of truth for governance |
| **entity_lifecycle** | Lifecycle event log for identities |
| **card_link** | card‚Üîcode implementation relationship. Includes anchor, rationale, stale_status |
| **relation_type_registry** | (domain, key) registry for relation types. Referenced by `*_relation.relation_type_id` |
| **card_relation** | card‚Üîcard relationships (contains/depends_on/extends, etc.). Project scope |
| **code_relation** | code‚Üîcode static analysis relationships (imports/extends/calls, etc.). Workspace scope |
| **card_evidence** | Implementation evidence for card_link. Polymorphic (code_link, test_pass, annotation, manual_review, ai_verification) |
| **coverage** | Implementation progress of card subtree. Recursive weighted aggregation |
| **stale link** | Existing link not re-verified after card body update |
| **CardStatus** | Card lifecycle state: draft, proposed, accepted, implementing, implemented, verified, deprecated |
| **CardPriority** | Card priority: P0(blocker), P1(critical), P2(major), P3(minor) |
| **structural versioning** | History management of card tree structure changes (reparent) |
| **composite coverage** | Recursive coverage aggregation with weight weighting |

## Appendix B: Related File List

| File | Change Type | Content |
|------|-----------|------|
| `tooling/mcp/drizzle/schema.ts` | **Rewrite** | Add entity_identity, entity_version, entity_lifecycle, approval_event, card_link, card_relation, code_relation, card_evidence. Remove entity, relation, relation_evidence |
| `tooling/mcp/src/server.ts` | Modify | Register new tools |
| `tooling/mcp/src/tools/card.ts` | **New** | register_card, link_card, unlink_card, move_card, update_card_status, relate_cards, unrelate_cards |
| `tooling/mcp/src/tools/identity.ts` | **New** | resolve_identity_candidates, apply_identity_rewrite |
| `tooling/mcp/src/tools/governance.ts` | **New** | rollback_approval |
| `tooling/mcp/src/tools/dashboard.ts` | **New** | card_impact, card_dashboard, coverage_map |
| `tooling/mcp/src/repo/identity-repo.ts` | **New** | entity_identity CRUD |
| `tooling/mcp/src/repo/version-repo.ts` | **New** | entity_version CRUD + status transition |
| `tooling/mcp/src/repo/card-link-repo.ts` | **New** | card_link CRUD + stale management |
| `tooling/mcp/src/repo/card-relation-repo.ts` | **New** | card_relation CRUD + cycle check |
| `tooling/mcp/src/repo/code-relation-repo.ts` | **New** | code_relation CRUD + orphan cleanup |
| `tooling/mcp/src/repo/card-evidence-repo.ts` | **New** | card_evidence CRUD |
| `tooling/mcp/src/repo/approval-repo.ts` | **New** | approval_event recording/query + payload validation |
| `tooling/mcp/src/repo/lifecycle-repo.ts` | **New** | entity_lifecycle recording/query |
| `tooling/mcp/src/repo/tenant-repo.ts` | **New** | tenant CRUD |
| `tooling/mcp/src/repo/project-repo.ts` | **New** | project CRUD |
| `tooling/mcp/src/repo/workspace-repo.ts` | **New** | workspace CRUD + archive (v4.3: no deletion, archive only) |
| `tooling/mcp/src/repo/user-repo.ts` | **New** | `"user"` CRUD (v4.3 B-1) |
| `tooling/mcp/src/tools/context.ts` | **New** | get_context, get_implementation_guide, get_subgraph (¬ß12.6) |
| `tooling/mcp/src/repo/entity-repo.ts` | **Remove** | Replaced by identity-repo + version-repo |
| `tooling/mcp/src/repo/relation-repo.ts` | **Remove** | Replaced by card-link-repo + card-relation-repo + code-relation-repo |
| `tooling/mcp/src/sync-worker.ts` | **Rewrite** | version append + @card parsing + stale detection |
| `tooling/mcp/src/kb.ts` | Modify | SyncAction extensions, new repo wrappers |
| `tooling/mcp/src/repo/sync-event-repo.ts` | Modify | FK changes |
| `tooling/mcp/src/repo/source-repo.ts` | Modify | FK changed to version reference |
| `tooling/mcp/src/repo/fact-repo.ts` | Modify | FK changed to version reference |
| `tooling/mcp/src/read-through.ts` | Modify | `__manual__/` exception + version-based |
| `tooling/mcp/drizzle/migrations/` | **New** | migration SQL |

## Appendix C: Test Matrix

### C.1 Identity Matching (Tier 1)

| # | Scenario | Precondition | Action | Expected Result |
|---|----------|-----------|------|-----------|
| T1-1 | Simple file move | identity+version+card_link exist on `a.ts` | `mv a.ts b.ts` ‚Üí startupScan | Existing version archived, new version active on same identity. card_link unchanged |
| T1-2 | Move + content change | link exists on `a.ts` | `mv a.ts b.ts` + content edit | hash mismatch ‚Üí new identity created. link broken (Tier 2) |
| T1-3 | File copy (1:N) | `a.ts` exists | `cp a.ts b.ts` + `rm a.ts` | 1:N auto matching prohibited. Existing archived, b.ts new identity |
| T1-4 | N:1 merge | `a.ts`, `b.ts` same hash | Delete both + create `c.ts` | N:1 auto matching prohibited |
| T1-5 | Watch DELETE‚ÜíCREATE | link exists on `a.ts` | DELETE(a.ts) ‚Üí CREATE(b.ts) | content_hash match ‚Üí new version on same identity |
| T1-6 | Watch reverse CREATE‚ÜíDELETE | `a.ts` exists | CREATE(b.ts) ‚Üí DELETE(a.ts) | Post-DELETE merge ‚Üí auto merge |
| T1-7 | Symbol-level cascade | 3 symbols + link on `a.ts` | `mv a.ts b.ts` | module identity match ‚Üí symbols also auto version add |

### C.2 Card Tools

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T2-1 | Root card registration | `register_card({projectId, cardKey: "card::auth"})` | identity created, version active, source `__manual__/card/card::auth` |
| T2-2 | Child card registration | `register_card({projectId, cardKey: "card::auth/login", parentCardKey: "card::auth"})` | identity created, contains relation auto-created |
| T2-3 | Nested card registration | `register_card({projectId, cardKey: "card::auth/login/oauth", parentCardKey: "card::auth/login"})` | 3-level depth normal |
| T2-4 | Card update | Re-call with body change | Existing version archived, new version active, `card_updated` |
| T2-5 | Card same content | Re-call with same body | `unchanged` |
| T2-6 | Link creation | `link_card({projectId, workspaceId, cardKey, codeEntityKey, rationale})` | card_link created, card_evidence created, `link_created` |
| T2-7 | Link duplicate | Re-call with same pair | upsert, `link_updated` |
| T2-8 | Unlink | `unlink_card({projectId, workspaceId, cardKey, codeEntityKey, reason})` | card_link deleted, `link_removed` |
| T2-9 | move_card | Parent change | Existing contains deleted, new contains created, `card_reparented` |
| T2-10 | move_card cycle | Attempt to move child as parent | Error: "Circular reference" |

### C.3 Card Lifecycle

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T3-1 | draft ‚Üí proposed | `update_card_status` | Status changed, `card_status_changed` |
| T3-2 | Invalid transition | draft ‚Üí verified | Error: "Cannot transition" |
| T3-3 | deprecated propagation | parent deprecated | All children also deprecated. Individual event per child. card_link stale_confirmed |
| T3-4 | Upper-bound warning (v4.2) | parent=accepted, attempt child=verified | Transition allowed + `warnings: ["Child status exceeds parent status"]` |
| T3-5 | verified evidence unmet (v4.2) | Attempt verified on card without evidence | Error: "No active evidence found" |

### C.4 Governance

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T4-1 | Link rollback | link_card ‚Üí rollback | card_link deleted, `link_rollback` |
| T4-2 | Status rollback | update_card_status ‚Üí rollback | Previous status restored + children restored |
| T4-3 | Already rolled back event | Attempt re-rollback | Error: "Already rolled back" |

### C.5 Purge

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T5-1 | Version purge | archived + TTL expired | version deleted. lifecycle FK ‚Üí NULL. evidence snapshot preserved |
| T5-2 | Identity purge | All versions gone + TTL | identity deleted ‚Üí card_link/code_relation cascade |
| T5-3 | card_link protection | card_link exists + no versions | identity NOT deleted |
| T5-4 | Identity purge without lifecycle | No lifecycle records + TTL | COALESCE fallback purge based on created_at |

### C.6 Coverage

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T6-1 | Flat coverage | Card with 3 children, 2 linked | 66.7% |
| T6-2 | Weighted coverage | weight 0.5, 1.0, 1.0 ‚Üí 2 linked (weight 1.0) | 80% |
| T6-3 | Nested coverage | 2 depth, some leaves linked | Recursive weighted aggregation |
| T6-4 | Tag cross-cutting aggregation | 3 out of 5 cards with #auth tag linked | 60% |

### C.7 Evidence

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T7-1 | code_link evidence | After link_card | evidence(type=code_link, is_active=true) |
| T7-2 | Annotation evidence | @card annotation detected | evidence(type=annotation, is_active=true) |
| T7-3 | Annotation removal | After @card annotation deleted + sync | is_active=false |
| T7-4 | Evidence snapshot | After version purge | snapshot preserved, fact_id=NULL |

### C.8 Stale Detection

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T8-1 | Existing link after card update | register_card(body changed) | stale_status = 'stale_candidate' |
| T8-2 | Anchor mismatch confirmation | inconsistency_report | stale_status = 'stale_confirmed' |
| T8-3 | Re-verification | Re-call link_card | stale_status = 'fresh', verified_at updated |

### C.9 Multi-branch Scenarios

| # | Scenario | Action | Expected Result |
|---|----------|------|-----------|
| T9-1 | Same file different branches | Modify same file in branch-a and branch-b | Independent version per workspace. card_link is project scope so shared |
| T9-2 | Sync after branch switch | Switch branch-a ‚Üí branch-b then startupScan | New version in branch-b workspace. branch-a data unchanged |
| T9-3 | Branch deletion | workspace archived (v4.3 A-4) | workspace.status='archived', code entity version archived, card_link stale_confirmed. card is project scope so unchanged. workspace record NOT deleted |
| T9-5 | Branch recreation (v4.3 A-3) | Recreate previously deleted branch-a | New workspace created (old workspace preserved in archived state). New workspace starts clean with startupScan. No old data contamination |
| T9-6 | Post-merge main link (v4.3 F-1) | card_link on branch-a then merge to main | On main sync, @card annotation-based links are auto-recreated. Manual links need reconnection on main |
| T9-4 | Same card linked on different branches | Link card::auth to code in branch-a and branch-b respectively | 2 card_links (different workspace_id). 1 card identity |

### C.10 E2E Integration Tests

| # | Scenario | Full Flow | Expected Result |
|---|----------|-----------|-----------|
| T10-1 | Full lifecycle | `register_card` ‚Üí `link_card` ‚Üí file move ‚Üí `startupScan` ‚Üí identity matching ‚Üí `coverage_map` | coverage maintained. card_link unchanged. identity matching auto |
| T10-2 | Stale ‚Üí re-verify | `register_card` ‚Üí `link_card` ‚Üí `register_card`(body changed) ‚Üí stale detection ‚Üí `link_card`(re-call) | stale_candidate ‚Üí fresh. verified_at updated |
| T10-3 | Deprecated cascade | `register_card`(parent) ‚Üí `register_card`(child) ‚Üí `link_card`(child) ‚Üí `update_card_status`(parent=deprecated) | parent+child deprecated. card_link preserved but stale marked |
| T10-4 | Rollback chain | `link_card` ‚Üí `rollback_approval` ‚Üí `register_card`(reconnect) | Original link deleted ‚Üí new link created. provenance chain complete |
| T10-5 | Multi-project isolation | Register card in project-a ‚Üí search in project-b | 0 search results in project-b. Isolation confirmed |

### C.11 Agent Workflow Scenarios (v4.2 F-1)

Scenarios validating agent's actual usage flow in vibe-coding:

| # | Scenario | Full Flow | Expected Result |
|---|----------|-----------|-----------|
| T11-1 | Card ‚Üí implementation | User `register_card` ‚Üí agent calls `get_implementation_guide` ‚Üí writes code ‚Üí calls `link_card` | card_link created. Coverage reflected. Agent implements referencing card body/acceptance_criteria |
| T11-2 | File open ‚Üí context | Agent opens file, calls `get_context({target: "src/auth.ts"})` | linkedCards, relatedCode returned. Agent recognizes related cards while coding |
| T11-3 | Card edit ‚Üí stale ‚Üí re-verify | User modifies card body ‚Üí stale detection ‚Üí agent checks stale via `card_dashboard` ‚Üí re-calls `link_card` | stale_candidate ‚Üí fresh. verified_at updated |
| T11-4 | Refactoring ‚Üí identity preservation | Agent moves/renames file ‚Üí startupScan ‚Üí identity matching | card_link auto-preserved. Agent confirms same card connection on next `get_context` call |
| T11-5 | Bottom-up implementation | User registers parent card + child cards ‚Üí agent implements from leaf ‚Üí child verified ‚Üí parent verified | Only upper-bound warning returned. Bottom-up flow works normally |
| T11-6 | Subgraph exploration | Agent calls `get_subgraph({center: "card::auth", hops: 2})` | card tree + linked code + dependencies graph returned. Agent understands impact scope |

## Appendix D: Change Summary vs Current

| Area | Current | v4 | Change Reason |
|------|----|----|-----------|
| Identity carrier | `entity.id` | `entity_identity.id` | Schema-level enforcement |
| File move handling | entity_key rewrite | version append | Complexity removal |
| grace window | Required | **Not required** | Identity provides protection |
| Spec model | 1 spec = 1 blob | **card nested tree** (unlimited depth) | Hierarchical requirement management |
| entity_type | spec, claim | **card** (single) | Unified model |
| Relation table | relation (single) | **card_link + card_relation + code_relation** (3 types) | Separation by nature |
| evidence | relation_evidence (fact reference only) | **card_evidence** (5-type polymorphism) | test, annotation, etc. |
| card attributes | None | **status, priority, tags, weight, template, external_refs** | Classification/filter/weighting |
| card lifecycle | None | **7-stage state machine + downward propagation + upper-bound warning (soft)** | Workflow tracking |
| coverage | Flat ratio | **Recursive weighted aggregation + tag cross-cutting + workspace filter** (v4.3) | Precise progress |
| Audit model | sync_event | approval_event (CHECK + payload validation) | Governance |
| Undo | None | rollback_approval | Reversibility |
| purge | Physical deletion | version purge (evidence preserved) ‚Üí identity purge (COALESCE fallback) | Audit preservation |
| workspace lifecycle | None | **append-only + archive** (v4.3). No deletion, soft delete | Branch-pattern-independent integrity |
| User identification | None | **`"user"` table + actor_id FK** (v4.3) | N-person audit tracking |
| KB focus | code-centric | **card-centric** | Requirement-centric |
| Connection direction | code‚Üíspec manual only | + **@card auto, glob pattern, external_refs** | Bidirectional |
| Implementation strategy | big-bang | dual-read + feature flag | Gradual transition |
| Deployment model | Single user | **N MCP : 1 DB** (v4.3) | Team collaboration support |
| Tools | Existing 18 | Existing 18 + **15 new** (register_card, link_card, unlink_card, move_card, update_card_status, relate_cards, unrelate_cards, card_impact, **card_dashboard**, coverage_map, rollback_approval, resolve/apply, **get_context, get_implementation_guide, get_subgraph**) | card model + lifecycle + **context retrieval** |
| Coverage accuracy | link exists = covered | **Evidence-based + stale excluded** (v4.4) | Prevent overestimation |
| Agent guide | None | **Workflows A~D + AGENTS.md integration** (v4.4) | Codified tool usage order |
| Inconsistency check | stale link, orphan | + **card_key path mismatch** (v4.4) | Detect mismatch after move_card |
| Workspace query safety | Implicit | **Archived exclusion pattern + write blocking** (v4.4) | Operational safety |
| user_id config | Recommended | **Mandatory (startup refused if not set)** (v4.4) | Audit tracking guarantee |
| FTS DDL | None | **search_tsv TSVECTOR + GIN + trigger** (v4.5) | Search tool implementation enabled |
| source/fact DDL | ¬ß14 only | **Formally included in ¬ß3.3** (v4.5) | Self-contained |
| version project_id consistency | App-guaranteed only | **Trigger added** (v4.5) | identity‚Üîversion consistency enforced |
| PK generation strategy | Unspecified | **ULID recommended** (v4.5) | workspace.id collision prevention |
| Retry monitoring | None | **Metrics recording** (v4.5) | Advisory lock transition decision |
| Document self-containment | Required previous docs | **Self-contained** (v4.6) | Independently understandable without previous docs |
| FTS strategy | Single | **Dual-index (pg_bigm filter + search_tsv ranking)** (v4.7) | Korean matching + accuracy ranking |
| deprecated event | Mixed with link_removed | **link_staled separated** (v4.7) | Distinguish physical deletion from stale marking |
| Card versioning policy | Unspecified | **Explicit field-set criteria** (v4.7) | Version increment only on body+summary+criteria change |
| Migration mapping | Comment-code mismatch | **implements separate path** (v4.7) | Direct card_link migration |

---

> **Document status**: v4.7 (8 contradiction/ambiguity fixes ‚Äî 2026-02-11). F-1 FTS dual-index role separation (pg_bigm=filter, search_tsv=ranking), F-2 user_id seed comment policy unification (fallback removed), F-3 link_staled event separation on deprecated (distinguished from link_removed semantics), F-4 register_card versioning policy codified (body+summary+criteria=version, rest=in-place), F-5 migration implements mapping comment-code mismatch fix (separate path), F-7 workspace archive stale_candidate inclusion, F-9 coverage subtree aggregation strategy specified (leaf=SQL, aggregation=app), F-10 card_dashboard linkedChildren‚ÜícoveredChildren rename.
