## 🔄 Transformer

Bunner의 Transformer는 직관적인 선언형 개발 방식을 유지하면서, 런타임 성능 비용을 제로(Zero)로 만드는 것을 목표로 한다. AOT 컴파일러가 개발자의 의도를 분석하여 최적화된 코드를 대신 작성해 주는 형태로 동작한다.

### Key Philosophy & Features

- **Zero Runtime Overhead (제로 런타임 오버헤드):**
  - 프로그램 실행 중에 객체의 구조를 분석하거나 변환 규칙을 탐색하는 과정을 없앤다. 사람이 수동으로 최적화하여 작성한 코드와 동일한 성능을 내는 정적 코드를 생성한다.

- **Smart Inference (지능형 추론):**
  - 개발자가 일일이 변환 규칙을 명시하지 않아도, 컴파일러가 코드의 문맥을 이해하여 자동으로 처리한다. 기본 데이터 타입이나 명시적인 클래스 타입이 감지되면, 가장 최적화된 변환 로직을 스스로 적용하여 개발 생산성을 높인다.

- **Security by Default (보안 중심 설계):**
  - **Implicit Stripping:** 외부에서 유입되는 데이터 중, 애플리케이션에 정의되지 않은 불필요한 속성은 변환 과정에서 자동으로 제거하여 데이터 오염 및 보안 취약점을 원천 차단한다.
  - **Safe Instantiation:** 데이터 객체를 생성할 때 발생할 수 있는 런타임 오류를 방지하기 위해, 안전한 초기화 규칙을 준수하도록 유도한다.

- **Separation of Concerns (역할의 명확한 분리):**
  - **Structural Definition (구조적 정의):** 단순한 값의 변경이 아니라, 데이터를 특정 클래스의 인스턴스나 날짜(Date)와 같은 표준 객체로 구체화하는 "생성(Creation)"의 역할을 담당한다. 순환 참조와 같은 복잡한 참조 관계에서도 안전하게 객체를 조립할 수 있는 메커니즘을 제공한다.
  - **Logic Application (로직 적용):** 데이터의 형태를 가공하거나 사용자 정의 비즈니스 로직을 주입하는 "변형(Manipulation)"의 역할을 담당한다. 입력 데이터를 객체로 만들 때와 객체를 다시 내보낼 때의 로직을 명확히 분리하여 관리할 수 있는 체계를 지원한다.

- **Context-Aware Serialization (상황별 노출 제어):**
  - 하나의 데이터 모델을 관리자용, 일반 사용자용 등 다양한 상황에 맞춰 다르게 표현할 수 있는 기능을 제공한다. 런타임에 조건을 검사하는 대신, 상황별로 전용 변환 코드를 미리 생성하여 성능 저하 없이 유연한 데이터 표현을 가능하게 한다.

### ⚙️ CLI - @bunner/cli

애플리케이션 빌드 단계에서 데이터 모델을 분석하여 실제 실행 가능한 코드를 생성하는 엔진이다. 런타임 라이브러리에 대한 의존성 없이 독립적으로 동작하는 순수 자바스크립트 코드를 만들어낸다.

- **Serializer Generator (직렬화 코드 생성):**
  - 데이터의 구조 중 변하지 않는 부분(키 이름, JSON 구문 등)은 상수로 미리 고정하고, 변하는 데이터만 빠르게 바인딩하는 최적화된 템플릿 코드를 생성한다.
  - 문자열 처리나 특수문자 변환과 같이 빈번하게 호출되는 유틸리티 로직은 외부 함수 호출을 피하고, 검증된 고성능 코드를 생성된 파일 내부에 직접 포함시켜 실행 속도를 극대화한다.

- **Deserializer Generator (역직렬화 코드 생성):**
  - 외부 데이터를 내부 객체로 변환할 때, 반복문이나 동적 탐색을 사용하지 않는다. 원본 데이터의 필드를 타겟 객체의 속성에 1:1로 직접 할당하는 단순하고 강력한 코드를 생성하여 엔진 처리 효율을 높인다.
  - 구조적 정의나 커스텀 로직이 필요한 필드에 대해서는 해당 변환 로직을 코드가 할당되는 시점에 인라인 형태로 주입한다.

### 📐 Common - @bunner/common

프레임워크 사용자와 컴파일러 간의 약속을 정의하는 인터페이스 계층이다. 실제 동작 로직은 포함하지 않으며, 개발자가 변환 규칙을 선언적으로 명세할 수 있는 도구들을 제공한다.

- **Visibility Control (노출 범위 제어):**
  - 데이터 변환 과정에서 포함할 필드와 제외할 필드를 명확히 지정하고, 특정 상황(Context)에서만 노출되어야 하는 필드 그룹을 정의하는 기능을 제공한다.

- **Structural Transformation Definition (구조 변환 정의):**
  - 중첩된 객체나 배열, 혹은 특수한 인스턴스화 과정이 필요한 필드에 대해 그 구조적 관계를 명시하는 도구를 제공한다. 컴파일러는 이를 통해 객체 생성 그래프를 파악하고 최적화된 파서(Parser)를 연결한다.

- **Custom Logic & Manipulation (커스텀 로직 정의):**
  - 단순한 타입 변환을 넘어선 값의 가공이나 계산 로직을 적용할 수 있는 수단을 제공한다.

- **Bidirectional Conversion Interface (양방향 변환 인터페이스):**
  - 복잡한 변환 로직을 작성할 때, 데이터를 받아들일 때(Input)와 내보낼 때(Output)의 처리를 명확히 구분하여 구현할 수 있는 표준 규격을 제공한다. 이를 통해 변환 로직의 재사용성을 높이고 유지보수를 용이하게 한다.
