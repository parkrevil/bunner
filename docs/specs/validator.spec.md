## ✅ Validator

`class-validator`의 익숙한 선언형 검증 방식을 유지하되, 런타임에 외부 검증 라이브러리에 의존하지 않고 순수 자바스크립트 로직으로 컴파일되는 제로 디펜던시(Zero Dependency) 검증 시스템을 구축한다.

### Key Philosophy & Features

- **Zero Runtime Dependency (제로 런타임 의존성):**
  - 실행 시점에 `class-validator`나 `zod`, `joi`와 같은 무거운 외부 라이브러리를 전혀 사용하지 않는다. 오직 컴파일러가 생성한 순수 조건문만으로 동작하여 가장 가벼운 실행 환경을 보장한다.

- **Result-Oriented Architecture (결과 지향적 설계):**
  - 검증 실패 시 예외(Exception)를 던져 흐름을 끊는 대신, 실패의 원인과 세부 내용을 담은 결과 객체(Result)를 반환한다. 이를 통해 검증 로직을 제어 흐름의 일부로 자연스럽게 통합하고, `try-catch` 블록 없는 깔끔한 코드를 유도한다.

- **Native Operator Optimization (네이티브 연산 최적화):**
  - 런타임에 메타데이터를 순회하며 검증 규칙을 찾는 과정을 제거한다. 빌드 타임에 검증 규칙을 분석하여 `typeof`, `length`, 정규식 검사 등 자바스크립트 엔진이 가장 빠르게 처리할 수 있는 네이티브 연산자 코드로 변환한다.

- **Schema-less & POJO (스키마리스 구조):**
  - 검증을 위해 별도의 스키마 객체를 메모리에 생성하거나 유지하지 않는다. 검증 실패 시 생성되는 에러 객체 또한 메서드가 없는 순수한 데이터 객체(POJO)로 구성하여 직렬화와 전송 효율을 높인다.

- **Hybrid Validation Strategy (하이브리드 검증 전략):**
  - 복잡한 요청 본문(Body)은 구조적인 **DTO 클래스**를 사용하여 검증하고, 단순한 쿼리 파라미터나 경로 변수는 별도의 클래스 정의 없이 **핸들러 인자에 직접 데코레이터**를 부착하여 검증하는 두 가지 방식을 모두 지원한다.

- **Virtual DTO Binding (가상 DTO 바인딩):**
  - AOT 컴파일러는 핸들러 인자에 부착된 검증 데코레이터(`@Min`, `@IsInt` 등)를 감지하면, 이를 마치 익명의 DTO가 존재하는 것처럼 취급하여 **인라인 검증 로직(Inline Validation Logic)**을 생성한다. 이를 통해 `ParseIntPipe`와 같은 런타임 변환기 없이도 타입 안전성과 유효성 검증을 동시에 달성한다.

### ⚙️ CLI - @bunner/cli

- **Branch Prediction Optimization (분기 예측 최적화):**
  - 검증 로직을 생성할 때, 가장 빈번하게 실패할 가능성이 높은 조건을 상단에 배치하거나 중첩된 검증을 평탄화(Flatten)하여 CPU의 분기 예측 효율을 높일 수 있는 코드를 생성한다.
- **Fail-Fast Code Generation:**
  - 전체 검증을 수행하는 모드와 첫 번째 실패 시 즉시 중단하는 모드를 지원하며, 이에 맞춰 불필요한 연산을 수행하지 않는 최적화된 코드를 각각 생성한다.

### 📐 Common - @bunner/common & 💎 Core - @bunner/core

- **Marker Decorators (마커 데코레이터):**
  - 실제 검증 로직은 포함하지 않고, 컴파일러에게 검증 규칙(문자열 여부, 길이 제한, 이메일 형식 등)을 전달하는 메타데이터 역할만 수행한다.
- **Pluggable Failure Formatter (플러그인 가능한 포맷터):**
  - 프레임워크는 검증 실패에 대한 원시 데이터(필드명, 원인, 입력값)만 제공하며, 최종 응답 형태(에러 메시지 포맷, 다국어 처리 등)는 어댑터나 사용자가 주입한 포맷터에 의해 유연하게 결정될 수 있는 구조를 제공한다.
