## 🔌 Adapter

Bunner 프레임워크를 HTTP, WebSocket, gRPC 등 다양한 네트워크 프로토콜 및 실행 환경과 연결하는 물리적 계층이다. 프레임워크의 코어 로직과 프로토콜 구현체를 완벽하게 분리하여 확장성과 유연성을 극대화한다.

### Key Philosophy & Features

- **Protocol Translation (프로토콜 번역):**
  - 각 프로토콜 고유의 요청과 응답 객체를 프레임워크가 이해할 수 있는 표준 컨텍스트(Context)와 결과(Result)로 변환하는 역할을 담당한다. 프레임워크 내부 로직은 현재 어떤 프로토콜 위에서 동작하는지 알 필요가 없도록 격리된다.

- **Multi-Adapter Support (다중 어댑터 지원):**
  - 하나의 애플리케이션 인스턴스 위에서 여러 개의 어댑터를 동시에 구동할 수 있는 아키텍처를 지원한다. 예를 들어, 동일한 비즈니스 로직을 HTTP API와 WebSocket 이벤트 핸들러가 동시에 공유하여 처리할 수 있다.

- **Lifecycle Management (생명주기 관리):**
  - 서버의 시작과 종료, 연결 수립 및 해제와 같은 프로토콜 레벨의 생명주기를 관리하며, 이를 프레임워크 전체의 라이프사이클과 동기화하여 안정적인 운영을 보장한다.

### ⚙️ CLI - @bunner/cli

어댑터의 정적 명세(Manifest)를 기반으로 사용자의 컨트롤러와 실제 프로토콜 구현체를 물리적으로 연결(Wiring)하는 코드를 생성한다.

- **Manifest-Based Wiring (매니페스트 기반 연결):**
  - 어댑터 패키지가 제공하는 정적 매니페스트 파일을 읽어, 해당 어댑터가 지원하는 고유의 데코레이터(URL 경로, 메시지 패턴 등)를 해석한다. 이를 바탕으로 런타임 라우터 등록 코드를 자동으로 생성하여, 어댑터 개발자가 별도의 컴파일러 플러그인을 작성하지 않아도 AOT 최적화를 누릴 수 있게 한다.

- **Runtime Bootstrapping Generator (구동 코드 생성):**
  - 사용자가 설정한 어댑터들을 초기화하고, 프레임워크의 라이프사이클에 등록하는 부트스트랩 코드를 생성한다. 여러 어댑터가 등록된 경우, 각 어댑터의 구동 순서와 의존성을 고려하여 병렬 또는 직렬로 실행되는 최적화된 시동 시퀀스를 작성한다.

### 📐 Common - @bunner/common

어댑터 구현체가 반드시 준수해야 하는 **표준 인터페이스와 통신 규약(Protocol Contract)**을 정의한다.

- **Adapter Interface & Manifest Schema:**
  - 모든 어댑터가 구현해야 하는 표준 메서드(서버 시작/종료, 요청 처리 위임 등)와, CLI가 어댑터의 기능을 이해하기 위해 필요한 매니페스트 파일의 JSON 스키마를 정의한다.

- **Abstract Context & Result Definition:**
  - 프로토콜에 종속되지 않는 추상화된 요청 컨텍스트와 응답 결과 객체의 타입을 정의한다. 이를 통해 어댑터 개발자는 자신의 프로토콜 데이터를 이 표준 규격에 맞춰 변환하는 것만으로 프레임워크와 연동할 수 있다.

### 💎 Core - @bunner/core

어댑터가 요청을 받아 비즈니스 로직으로 전달할 때 거쳐야 하는 **표준 실행 파이프라인(Execution Pipeline)**을 구성할 수 있는 API와 타입을 제공한다.

- **Declarative Pipeline Definition (선언적 파이프라인 정의):**
  - 어댑터 개발자가 `Middleware -> Guard -> Handler`로 이어지는 실행 흐름을 직관적으로 정의할 수 있는 **Simple Pipeline Definition API**를 제공한다.
  - 런타임 엔진이 존재하지 않으며, 이 정의를 바탕으로 CLI가 최적화된 코드를 생성한다.

- **Unified Error Filter Chain (단일화된 에러 필터 체인):**
  - 모든 예외 처리는 **Error Filter**가 담당한다는 단일 원칙을 제공한다.
  - 어댑터 구현체는 별도의 예외 처리 로직(try-catch)을 작성할 필요 없이, 프레임워크가 생성한 필터 체인을 통해 모든 예외가 표준 결과(Result)로 변환됨을 보장받는다.
