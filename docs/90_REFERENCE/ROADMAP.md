# ROADMAP

Bunner 프레임워크의 개발 방향과 목표, 필요한 패키지를 정하고 초안을 기술한다.

---

## 🎯 목표

Bunner는 VISION.md를 핵심 가치관으로 둔다.

- Bun 환경에서만 동작하는 프레임워크를 구축한다.
- 장황한 설명 없이 구조와 코드가 프레임워크를 설명할 수 있어야 한다.
- 사용자의 러닝커브를 최소화 해야한다.
- 쉬운 방법 보단 단순한 방법을 제공한다.
- 명확하고 직관적이며 투명한 사용성을 제공한다.
- 백엔드 프레임워크의 뜨거운 감자를 고려하여 개발자들의 고충을 해결하기 위해 최선을 다한다.
- reflect-metadata를 사용하지 않는다.
- Multi-App, Multi-Adapter 지원

---

## 📝 메모

- bunfig.toml 사용 및 최적화 검토
- bun:bundle의 feature 사용 검토
  - 사용자가 사용한 feature만 골라내서 CLI에서 알아서 Build 스크립트를 최적화 할 수 있을까?

---

## 🧰 기능 및 DX

- Angular 및 NestJS의 아키텍처 및 DX
- 고속
- 가벼움
- AST, AOT
- DI
- Pre-built Pipeline
- Adapter
- Middleware
- Guard
- Error Filter
- Result<T, E>
- Transformer
- Validator
- MCP
- Cluster Manager
- Like Nestjs Devtools
- Rust FFI Adapter Core

---

## ⚙️ CLI - @bunner/cli

Bunner의 CLI는 단순한 빌드 도구가 아니라, 프레임워크의 **유일한 지능 계층**이다.  
CLI는 실행 시점에 동적으로 조립되는 런타임 엔진을 만들지 않는다. 대신, 빌드 타임에 가능한 한 많은 실행 인프라를 AOT로 생성하여 런타임을 단순한 함수 호출과 변수 할당 수준으로 축소한다.

CLI의 목적은 다음 두 가지다.

1. 실행 이전에 가능한 한 많은 구조적 문제를 드러낸다.
2. 그 경계를 넘어서는 영역은 사용자 구현과 자유에 위임한다.

---

### Compiler & Interpretation

CLI는 단순한 코드 스캐너가 아니라, **실행 모델을 구성하는 정적 분석기**다.

- CLI는 빌드 타임에 가능한 실행 경로를 분석하고, 실행 순서가 확정 가능한 구조를 코드로 생성한다.
- 도달 불가능한 경로, 충돌하는 적용 순서, 누락된 처리와 같은 구조적 문제를 빌드 타임에 판정한다.
- 정적으로 해석할 수 없는 구조에 대해서는 추측하거나 보정하지 않는다.
- 대신, 어디까지가 확정 가능한 영역이고 어디부터가 사용자 책임 영역인지를 명확히 드러낸다.

---

### Code Generation Boundary

CLI는 비즈니스 로직을 생성하거나 변형하지 않는다.  
CLI가 생성하는 것은 **실행 인프라**다.

CLI는 다음과 같은 코드를 생성할 수 있다.

- 개발 환경과 배포 환경에 맞는 Manifest
- 어댑터의 정적 명세를 기반으로 한 Wiring 코드
- 어댑터 초기화 및 프레임워크 라이프사이클을 연결하는 부트스트랩 코드
- 미들웨어, 가드, 핸들러 실행 흐름을 단일 함수 호출 체인으로 컴파일한 실행 코드
- 예외 발생 시 Error Filter 체인으로 즉시 점프하도록 하는 제어 흐름 코드
- 성능, 안정성, 관측을 위해 필요한 표준 계측 및 실행 컨텍스트 전달 코드

CLI는 사용자 함수의 본문을 재작성하지 않는다.  
다만 실행 인프라를 구성하기 위해, 사용자 코드 호출 **주변의 제어 흐름**은 AOT로 생성한다.

---

### Metadata Lifecycle & Immutability

CLI가 생성하는 메타데이터(파이프라인 구조, 의존성 그래프, 실행 계획 등)는 런타임에 동적으로 변경될 수 없다.

- **Immutability (불변성):** 생성된 메타데이터는 초기화 시점에 확정되며, 실행 중 수정은 원천 차단된다.
- **Lifecycle-Based Cleanup (생명주기 기반 소거):**
  - 메타데이터는 앱 구동 초기화(Bootstrap) 단계에서만 참조된다.
  - 구동이 완료된 특정 라이프사이클 시점에, 실행에 불필요한 설계 정보는 메모리에서 즉시 제거(Cleanup)된다.
  - 이를 통해 런타임 메모리 사용량을 최소화하고, 실행 도중 설계 정보에 접근하여 구조를 변경하려는 시도를 방지한다.

---

### Structural Context Propagation

CLI는 에러뿐 아니라 다양한 관측 지점에서 **구조적 실행 컨텍스트**가 충분히 드러나도록 지원한다.

- 이 컨텍스트는 “어디에서”, “어떤 단계에서”, “어떤 경로로” 실행되었는지를 나타낸다.
- CLI는 이러한 정보를 런타임 추측이나 스택 트레이스에 의존하지 않는다.
- 빌드 타임에 확정 가능한 컨텍스트는 코드로 명시하여 전달한다.

이 개입은 비즈니스 의미를 변경하기 위한 것이 아니라,  
실행 인프라의 좌표계를 명확히 하기 위한 것이다.

---

### Adapter Evaluation & Enforcement

CLI는 어댑터를 문서 선언이나 의도로 신뢰하지 않는다.  
어댑터의 자동화 가능성은 **빌드 및 검증 단계에서 구조적으로 판정**된다.

- 이 판정은 가능성을 제시하는 것이 아니라, 현재 구조에서 가능한 자동화의 상한선을 드러낸다.
- 판정 결과는 설정이나 옵션으로 우회할 수 없다.
- 구조가 바뀌지 않으면 결과도 변하지 않는다.

---

### Failure Reporting Philosophy

CLI는 실패를 숨기거나 완화하지 않는다.

모든 실패 메시지는 다음을 포함해야 한다.

- 무엇이 실패했는가
- 어디에서 실패했는가
- 구조적 원인은 무엇인가
- 해결이 가능한 경우에만, 필요한 구조적 변경 방향

CLI는 누락된 정보를 추측해서 채우지 않는다.  
추측이 필요한 순간, 그 자체가 실패 사유다.

### Discovery & Project Structure

Bunner의 Discovery는 “파일을 찾는 기능”이 아니라,  
프로젝트 전체를 스캔하여 실행 모델(AOT)을 구성하기 위한 **구조적 사실(Structural Facts)**을 수집하는 단계다.

Discovery는 사용자의 디렉토리 구조 자유를 침해하지 않는다.  
CLI는 프로젝트 구조를 변경하거나 “권장 구조”를 강제하지 않으며, 파일 시스템을 그대로 읽고 해석한다.

---

#### Module Boundary (Directory-First)

Bunner의 모듈 시스템은 코드 내 선언 목록(controller/providers/exports 등)에 의존하지 않는다.  
모듈 경계는 **디렉토리 기반**으로 인식되며, 모듈 정의 파일이 존재하는 디렉토리가 모듈 루트로 취급된다.

모듈 정의 파일이 없는 디렉토리에 존재하는 구성요소는  
가장 가까운 상위 모듈로 귀속되는 모델을 기본으로 한다.

이 방식은 사용자가 구조를 자유롭게 구성하더라도,  
CLI가 프로젝트 전체를 일관되게 해석할 수 있도록 한다.

---

#### Role Identification (Decorator-Driven, Manifest-Based)

Discovery 단계에서 CLI는 프로젝트 전체를 스캔하되,  
“무엇이 프레임워크 구성요소인지”는 **데코레이터/마커 기반으로 판정**한다.

CLI는 데코레이터 의미를 하드코딩하지 않는다.  
`Common` 및 `Adapter`가 제공하는 Manifest를 로드하여,  
“어떤 표식이 어떤 역할을 의미하는지”를 통합 딕셔너리로 구성한 뒤 동일한 판정 로직을 적용한다.

즉, 사용자 구조는 자유롭지만 “프레임워크가 인지하는 역할”은 명시적 표식으로 결정된다.

---

#### Independent Units (Cron / Worker / Script)

프로젝트에는 요청 처리와 무관한 독립 실행 유닛(예: cron, worker, scripts)이 존재할 수 있다.  
Bunner는 이를 예외 처리로 다루지 않고, 다음 두 경로로 일관되게 인식한다.

- **표식 기반 인식:** 독립 유닛은 역할 데코레이터/마커로 표현될 수 있으며, CLI는 이를 인덱싱한다.
- **명시 기반 인식:** 표식이 적합하지 않은 경우, 독립 유닛은 config를 통해 명시적으로 선언될 수 있다.

CLI는 추측으로 독립 유닛을 자동 분류하지 않는다.  
독립 유닛은 “명시적으로 인지 가능한 형태”로만 CLI의 세계에 포함된다.

---

#### Incremental Indexing (Dev)

개발 환경의 Discovery는 전체 재스캔을 반복하는 모델이 아니라,  
watch 이벤트를 기반으로 한 **증분 인덱싱**을 기본으로 한다.

CLI는 변경된 파일과 그 영향 범위를 추적하여,  
필요한 부분만 재판정하고 필요한 생성물만 재생성한다.

---

#### Failure Model (Discovery)

“전역 스캔인데 왜 안 잡히지?”는 파일 발견의 문제가 아니다.  
Discovery에서 문제는 대부분 다음 중 하나로 발생한다.

- 역할 표식이 존재하지만, 로드된 Manifest 딕셔너리에서 의미가 정의되지 않음
- 역할 판정은 가능하지만, 귀속(모듈 경계/흡수 규칙)이 확정되지 않음
- 역할 표식이 존재하지만, 로드된 Manifest 딕셔너리에서 의미가 정의되지 않음
- 역할 판정은 가능하지만, 귀속(모듈 경계/흡수 규칙)이 확정되지 않음
- **명시적 마커/설정** 없이 추측으로 감지하려 함 (CLI는 추측하지 않음)
- 여러 규칙이 충돌하여 실행 모델을 확정할 수 없음

CLI는 이를 “발견 실패”로 숨기지 않고,  
“판정 실패/귀속 실패/규칙 충돌”로 명확히 드러낸다.

---

### 명령어 (Commands)

#### Management & Lifecycle

- **`bunner new` / `bunner init`**
  - **기능**: 프레임워크 표준 구조를 갖춘 새 프로젝트 생성.
  - **원칙**: 불필요한 질문 없이 가장 표준적인(Kosher) 상태로 시작.
- **`bunner upgrade`**
  - **기능**: 코어 및 의존성 업데이트.
- **`bunner info` / `bunner version`**
  - **기능**: OS, Bun, Bunner 버전 및 활성 어댑터 등 환경 정보 덤프.

#### Development & Build

- **`bunner dev`**
  - **기능**: 개발 서버 실행, 파일 감지, 증분 빌드.
  - **원칙**: **Max Info**. 모든 디버깅 정보와 소스맵을 포함.
- **`bunner build`**
  - **기능**: 프로덕션용 최적화 아티팩트 생성.
  - **원칙**: **Min Info**. 실행에 불필요한 메타데이터 제거 및 코어 로직 불변화.
- **`bunner clean`**
  - **기능**: `.bunner` 디렉토리 및 캐시 초기화.
  - **원칙**: 꼬인 상태(State Drift)에서의 확실한 복구 수단.

#### Code Quality

- **`bunner firebet`**
  - **기능**: 사용자가 명시한 코드 스타일 및 TypeScript 문법 사용을 엄격하게 검사.
  - **원칙**: 아키텍처 강제(CLI Build)가 아닌, 팀 내 컨벤션 및 타입 최적화(Quality Assurance)를 위한 린팅 도구.
  - **옵션**:
    - `--fix`: 자동 수정.
    - `--audit`: 보안 취약점 등 심층 검사.

### Adapter Wiring & Bootstrapping (from Adapter Spec)

어댑터의 정적 명세(Manifest)를 기반으로 사용자의 컨트롤러와 실제 프로토콜 구현체를 물리적으로 연결(Wiring)하는 코드를 생성한다.

- **Manifest-Based Wiring (매니페스트 기반 연결):**
  - 어댑터 패키지가 제공하는 정적 매니페스트 파일을 읽어, 해당 어댑터가 지원하는 고유의 데코레이터(URL 경로, 메시지 패턴 등)를 해석한다. 이를 바탕으로 런타임 라우터 등록 코드를 자동으로 생성하여, 어댑터 개발자가 별도의 컴파일러 플러그인을 작성하지 않아도 AOT 최적화를 누릴 수 있게 한다.

- **Runtime Bootstrapping Generator (구동 코드 생성):**
  - 사용자가 설정한 어댑터들을 초기화하고, 프레임워크의 라이프사이클에 등록하는 부트스트랩 코드를 생성한다. 여러 어댑터가 등록된 경우, 각 어댑터의 구동 순서와 의존성을 고려하여 병렬 또는 직렬로 실행되는 최적화된 시동 시퀀스를 작성한다.

### AOT Compilation Engine (from AOT/AST Spec)

CLI는 Bunner의 컴파일러이자 정적 분석 엔진이다.

- **AST Parsing & Analysis:**
  - TypeScript 코드를 파싱하여 AST를 생성하고, 이를 분석하여 애플리케이션의 구조(모듈, 컨트롤러, 프로바이더 등)를 파악한다.
  - 데코레이터와 타입 정보를 정적으로 해석하여 프레임워크가 필요로 하는 메타데이터를 추출한다.

- **Execution Infrastructure Generation:**
  - 분석된 정보를 바탕으로 실행 가능한 인프라 코드를 생성한다.
  - **Manifest Generation:** 개발 및 배포 환경에 맞는 정적 매니페스트 파일을 생성한다.
  - **Wiring Code:** 모듈과 컴포넌트 간의 연결 코드를 생성한다.
  - **Bootstrap Code:** 어댑터 초기화 및 프레임워크 라이프사이클을 연결하는 부트스트랩 코드를 생성한다.
  - **Pipeline Compilation:** 미들웨어, 가드, 핸들러 등의 실행 흐름을 단일 함수 호출 체인으로 컴파일한다.

- **Optimized Try-Catch Injection:**
  - 에러 처리를 위한 `try-catch` 블록을 필요한 위치에 자동으로 주입한다.
  - 런타임 성능 저하를 최소화하면서도, 예외 발생 시 즉시 필터 체인으로 제어 흐름이 이동하도록 코드를 구성한다.

### Dependency Injection Engine (from DI Spec)

DI 시스템의 핵심 엔진으로, 정적 분석과 코드 생성을 담당한다.

- **Dependency Graph Construction:**
  - 소스 코드를 분석하여 컴포넌트 간의 의존성 관계를 파악하고, 전체 애플리케이션의 의존성 그래프를 구축한다.
  - 생성자 파라미터 타입을 분석하여 주입할 대상을 식별한다.

- **Wiring Code Generation:**
  - 확정된 의존성 그래프를 순회하며, 올바른 순서대로 인스턴스를 생성하고 주입하는 코드를 생성한다.
  - 위상 정렬(Topological Sort)을 통해 생성 순서를 결정한다.

- **Circular Dependency Detection:**
  - 그래프 분석 과정에서 순환 참조가 발견되면 즉시 빌드를 중단하고, 순환 경로를 명확히 보여주는 에러 메시지를 출력한다.

### DTO Optimization (from DTO Spec)

DTO 정의를 활용하여 최적화된 코드를 생성한다.

- **Validation Schema Generation:**
  - DTO에 정의된 데코레이터와 타입 정보를 바탕으로, 런타임에 사용할 수 있는 고성능 검증 스키마를 미리 생성한다.
  - 불필요한 리플렉션 비용을 제거하고 검증 속도를 극대화한다.

- **API Documentation Extraction:**
  - `@bunner/docs`와 연동하여 DTO 구조를 분석하고, OpenAPI(Swagger) 등의 API 명세서에 자동으로 반영한다.

### Error Handling Injection (from Error Handling Spec)

- **Auto-Generated Try-Catch:**
  - 핸들러와 미들웨어 등 실행 지점 주변에 최적화된 `try-catch` 블록을 자동으로 생성한다.
  - 예외 발생 시 즉시 필터 체인의 시작점으로 점프하도록 제어 흐름을 연결한다.

### Module Scanning (from Module System Spec)

- **Recursive Scanner (재귀적 스캐너):**
  - 빌드 시점에 프로젝트의 전체 파일 시스템을 순회하며 모듈 정의 파일의 위치를 파악하고, 이를 기반으로 논리적인 모듈 트리를 구성한다.
  - 다른 모듈에서 참조되지 않더라도 독립적으로 실행되어야 하는 모듈(예: 크론 작업, 이벤트 리스너)을 이 단계에서 찾아내어, 누락 없이 애플리케이션에 포함시킨다.

- **Visibility Validator (가시성 검증기):**
  - 소스 코드의 `import` 구문을 분석할 때, 대상 컴포넌트의 가시성 설정(Internal/Export)을 확인한다. 규칙을 위반한 접근이 감지되면 컴파일을 중단하고 명확한 에러 메시지를 출력한다.

### Transformer Optimization (from Transformer Spec)

- **Optimized Transformer Generation:**
  - `class-transformer`와 유사한 기능을 제공하지만, 런타임 리플렉션을 사용하지 않는다.
  - DTO에 선언된 데코레이터를 분석하여, 순수 자바스크립트 함수로 구성된 변환 로직을 생성한다.

### Validation Optimization (from Validator Spec)

- **Validation Code Generation:**
  - DTO의 검증 데코레이터를 분석하여, 최적화된 검증 함수(Validator Function)를 생성한다.
  - 생성된 함수는 순차적으로 조건을 검사하며, 실패 시 상세한 에러 정보를 반환하도록 구성된다.

---

## 🛠️ DevTools - @bunner/devtools (Web UI)

시각적 분석이 필요한 기능(`graph`, `inspect`, `doctor`)은 CLI 커맨드가 아닌, **별도의 웹 기반 관리 도구**로 제공한다.

- **분리 원칙**: CLI는 터미널 실행과 빌드에 집중하고, 무거운 시각화 로직은 DevTools 패키지로 이관한다.
- **Web UI 제공**:
  - `bunner dev` 실행 시 `--devtools` 플래그나 별도 실행을 통해 웹 대시보드를 띄운다.
- **주요 기능**:
  - **Pipeline Visualization**: 어댑터별 파이프라인 흐름을 그래프로 시각화.
  - **Dependency Graph**: 모듈 간, 컴포넌트 간 의존성 관계 탐색.
  - **Manifest Inspector**: CLI가 생성한 불변 메타데이터의 내부 구조 조회.
  - **Health Check (Doctor)**: 시스템 환경 및 설정 유효성 시각적 진단.

---

## 📐 Common - @bunner/common

`@bunner/common`은 Bunner 생태계에서 **정적 계약(Contract)의 정본(SSOT)**을 제공하는 패키지다.
이 패키지는 “편의 기능 라이브러리”가 아니며, **실행 로직을 포함하지 않는다.**

### 0. 정체성 (Non-Executable)

`@bunner/common`은 다음을 **절대 포함하지 않는다.**

- 실행 코드(런타임 동작, 로직, 알고리즘)
- 헬퍼/유틸/빌더(편의 API)
- 환경 의존 코드(Bun/Node API 호출)
- 런타임 상태 저장소(reflect-metadata, 글로벌 레지스트리 등)

`common`은 오직 **타입/스키마/규약(문장으로 판정 가능한 계약)**만을 제공한다.

---

### 1. 무엇을 제공하는가 (Static Contracts)

`@bunner/common`은 아래 계약들을 “정적 정의”로 제공한다.

#### 1.1 Result & Domain Error Contract

- 도메인 실패는 `Result` 채널을 통해 표현된다.
- 도메인 에러는 `code`(기계적 식별자) + `meta`(직렬화 가능한 상세 정보)를 포함하는 **표준 컨테이너 규약**을 따른다.
- 도메인 의미에 특정 프로토콜(HTTP 상태 코드 등)의 표현을 포함하지 않는다.
- 외부 결과 타입(`fp-ts` 등)과의 상호운용은 “표준 포맷으로의 변환”이 가능해야 하며, `common`은 그 변환의 **계약(형태/경계)**만 정의한다. (변환 함수 자체는 `common`의 책임이 아니다.)

#### 1.2 Panic/System Error Contract

- 시스템 장애(Panic)는 예외(throw) 경로로 표현되는 것을 전제로 한다.
- Panic은 “도메인 에러”로 위장되지 않으며, 최상위 안전망에서 표준 시스템 에러 결과로 환원될 수 있어야 한다.
- `common`은 시스템 에러가 표준 결과로 환원될 때의 **형태/필드/제약**만 정의한다.

#### 1.3 Adapter Static Manifest Contract

어댑터는 자신이 제공하는 기능을 **정적 명세(Manifest)**로 기술할 수 있어야 한다.
`common`은 어댑터 정적 명세가 표현해야 하는 최소 의미를 계약으로 정의한다.

- 어댑터가 제공하는 데코레이터/마커의 의미(무엇을 선언하는 표식인지)
- 표식이 요구하는 바인딩 정보(예: 라우팅/이벤트 매핑에 필요한 최소 메타)
- 어댑터 capability 범위(지원하는 기능의 선언)
- 호환성 판정을 위한 버전 정보

정적 명세는 실행과 분리된 선언물이며, 불충분한 명세를 추측으로 보완하는 행위는 허용되지 않는다.

#### 1.4 DI Declaration Contract (Marker-Only)

DI는 선언 기반으로 동작하며, `common`은 선언이 따라야 하는 계약만 정의한다.

- 주입 가능한 구성요소를 선언하는 표식의 의미(“구성요소 선언”)
- 스코프/가시성 등 선언 가능한 속성의 범위
- 의존성 표식(Dependency Marker)이 표현할 수 있는 대상(토큰/타입 등)의 제약

DI 컨테이너 구현, 인스턴스 생성/캐싱/해결 로직은 `common`의 책임이 아니다.

#### 1.5 Transformer Declaration Contract

Transformer는 선언형 인터페이스를 유지하되, 런타임 오버헤드를 최소화하는 것을 전제로 한다.
`common`은 변환 선언이 표현하는 의미(노출/제외/그룹/컨텍스트, 입력/출력 구분 등)의 계약만 정의한다.

#### 1.6 Validator Declaration Contract

Validator 또한 선언형 인터페이스를 전제로 하며, `common`은 검증 선언이 표현하는 의미(규칙 식별, 파라미터, 실패 표현)의 계약만 정의한다.

### Adapter Contracts (from Adapter Spec)

어댑터 구현체가 반드시 준수해야 하는 **표준 인터페이스와 통신 규약(Protocol Contract)**을 정의한다.

- **Adapter Interface & Manifest Schema:**
  - 모든 어댑터가 구현해야 하는 표준 메서드(서버 시작/종료, 요청 처리 위임 등)와, CLI가 어댑터의 기능을 이해하기 위해 필요한 매니페스트 파일의 JSON 스키마를 정의한다.

- **Abstract Context & Result Definition:**
  - 프로토콜에 종속되지 않는 추상화된 요청 컨텍스트와 응답 결과 객체의 타입을 정의한다. 이를 통해 어댑터 개발자는 자신의 프로토콜 데이터를 이 표준 규격에 맞춰 변환하는 것만으로 프레임워크와 연동할 수 있다.

### AOT Contracts (from AOT/AST Spec)

AOT 컴파일러가 생성하는 코드와 런타임이 공유하는 정적 계약을 정의한다.

- **Manifest Schema:**
  - CLI가 생성하는 매니페스트 파일의 구조를 정의한다. 이 스키마는 컴파일러와 런타임 간의 통신 규약 역할을 한다.

- **Static Symbols & Markers:**
  - 컴파일러가 코드를 분석할 때 식별자로 사용하는 데코레이터와 마커들을 정의한다.
  - 이들은 런타임 로직을 포함하지 않으며, 오직 컴파일러에게 정보를 전달하는 용도로만 사용된다.

### DI Markers (from DI Spec)

DI 시스템을 위한 선언적 마커를 제공한다.

- **Dependency Markers:**
  - `@Injectable()`, `@Controller()` 등 컴포넌트의 역할을 정의하는 데코레이터를 제공한다.
  - `@Inject()`와 같이 특정 토큰이나 타입을 명시적으로 주입해야 할 때 사용하는 마커를 정의한다.
  - 이들은 런타임 로직 없이 오직 컴파일러에게 정보를 제공하는 메타데이터 역할만 수행한다.

- **Token & Type Definitions:**
  - 의존성 주입의 키로 사용되는 토큰과 타입 정의를 포함한다.

### DTO Decorators (from DTO Spec)

DTO 정의에 필요한 데코레이터와 유틸리티를 제공한다.

- **Validation Decorators:**
  - `@IsString()`, `@IsInt()`, `@Min()`, `@Max()` 등 데이터 검증 규칙을 선언하는 데코레이터를 제공한다. (Validator Spec 참조)

- **Transformation Decorators:**
  - `@Type(() => Number)` 등 데이터 변환 규칙을 선언하는 데코레이터를 제공한다. (Transformer Spec 참조)

- **Api Property Decorators:**
  - `@ApiProperty()` 등 API 문서화를 위한 메타데이터 데코레이터를 제공한다.

### Error Contracts (from Error Handling Spec)

- **Filter Interface:**
  - `catch(exception: unknown): Result | void` 형태의 단순한 인터페이스를 정의한다.
  - `Result` 반환 시 처리 완료, `void` 반환 시(또는 throw) 다음 필터로 위임을 의미한다.

- **Standard Error Types:**
  - `SystemError`, `DomainError` 등 에러의 성격을 구분하는 기본 타입과 인터페이스를 제공한다.

### Module Helpers (from Module System Spec)

- **Module Definition Helper (모듈 정의 헬퍼):**
  - 단순한 모듈의 경우 파일을 비워두거나 생략할 수 있도록 허용하며, 설정이 필요한 경우에만 메타데이터를 정의할 수 있는 헬퍼 함수를 제공한다.
  - 어댑터 설정, 프로바이더 등록, 전역 설정 오버라이딩 등 모듈 구성에 필요한 타입 정의와 스키마를 제공한다.

### Transformer Decorators (from Transformer Spec)

변환 규칙 선언을 위한 데코레이터를 제공한다.

- **Transformation Decorators:**
  - `@Type(() => Class)`: 중첩된 객체나 배열을 특정 클래스의 인스턴스로 변환한다.
  - `@Transform(({ value }) => ...)`: 커스텀 변환 로직을 적용한다.
  - `@Expose()`, `@Exclude()`: 직렬화 시 필드의 노출 여부를 제어한다.

### Validator Decorators (from Validator Spec)

검증 규칙 선언을 위한 표준 데코레이터를 제공한다.

- **Common Validators:**
  - `@IsString()`, `@IsNumber()`, `@IsBoolean()`: 기본 타입 검사.
  - `@IsOptional()`: 선택적 필드 처리.
  - `@Min()`, `@Max()`, `@Length()`: 범위 및 길이 검사.
  - `@Matches(regex)`: 정규식 패턴 검사.
  - `@ValidateNested()`: 중첩된 객체 검증.

- **Custom Validator:**
  - 사용자가 직접 검증 로직을 작성하여 데코레이터로 사용할 수 있는 확장 인터페이스를 제공한다.

---

### 2. 의존성 규칙 (Dependency Rule)

- `@bunner/common`은 어떠한 런타임 패키지도 의존하지 않는다.
- `@bunner/common`은 CLI/Core/Adapter/사용자 코드에서 **공통 언어로 소비**된다.
- `common`의 계약은 CLI/Core/Adapter 어디에서도 재정의되지 않는다.

---

### 3. 변경 원칙 (Stability)

`@bunner/common`은 생태계 전반이 의존하는 계약의 정본이므로 다음 원칙을 따른다.

- 작은 변경도 광범위한 파급을 가진다.
- 따라서 변경은 최소화하며, 변경이 필요할 경우 호환성 규칙을 우선한다.
- “편의”를 이유로 실행 코드나 유틸리티를 추가하지 않는다.

---

## 💎 Core - @bunner/core

### 1. 구동 및 실행 모델

#### 1.1 시작점의 성격

Bunner의 시작점은 “실행 가능한 앱”을 만든 뒤, 그 앱을 변경 불가능한 상태로 고정하는 데 목적이 있다.
Bunner는 런타임에서 구조가 바뀌는 시스템을 허용하지 않는다. 실행 전에는 무엇이든 준비할 수 있지만, 실행이 시작된 뒤에는 설계도가 남아 있으면 안 된다.

이 원칙은 다음의 결론으로 이어진다.

- 실행 이후 런타임은 “이미 만들어진 상태를 소비”할 뿐, “새로 조립”하지 않는다.
- 실행 이후 런타임은 “정의를 참고”하지 않는다.
- 실행 이후 런타임은 “동적 등록”을 하지 않는다.

#### 1.2 정적 모델과 불변성

Bunner는 애플리케이션의 구성 요소가 실행 중에 늘어나거나, 새로 결합되거나, 런타임에서 등록되는 방식을 배제한다.
즉, 실행 모델은 “정적 구조가 만들어지고, 그 이후에는 불변”이다.

이를 통해 다음이 가능해진다.

- 런타임이 단순해진다.
- 관측과 디버깅의 대상이 줄어든다.
- 시스템이 어떤 상태로 움직이는지 설명 가능해진다.

#### 1.3 개발 환경과 배포 환경의 정책 차이

Bunner는 개발 환경과 배포 환경의 목표가 다르다고 본다.

- 개발 환경의 목표는 “이해 가능성과 피드백 루프”다.
- 배포 환경의 목표는 “메모리 최소화와 실행 안정성”이다.

따라서 개발 환경에서는 구조를 설명해주는 정보가 남아 있어도 되지만, 배포 환경에서는 그 정보가 남아 있으면 안 된다.

즉, 개발 환경은 “관측 가능한 시스템”, 배포 환경은 “가볍고 단단한 시스템”이다.

#### 1.4 실행 이후 정리 전략

실행이 시작된 뒤에는 설계에 해당하는 정보가 런타임에 남아 있지 않아야 한다.
이때 “정리”는 단순한 메모리 절약이 아니라, **불변성 강제**에 가까운 의미를 가진다.

정리의 핵심은 두 가지를 분리하는 것이다.

- 실행에 필요한 것: 실제로 동작하는 상태
- 실행에 필요 없는 것: 설계를 설명하기 위한 정보

배포 환경에서는 후자를 즉시 소거함으로써, 런타임이 설계 정보를 참조하거나 변형할 가능성을 제거한다.

---

### 2. 클러스터 및 프로세스 관리

#### 2.1 목적

Bunner는 단일 인스턴스만을 전제로 하지 않는다. 멀티 코어 환경에서 프로세스를 늘리고, 재시작하며, 생명주기를 안정적으로 유지할 수 있어야 한다.

여기서 중요한 전제는 다음이다.

- 클러스터는 “요청 처리 로직”의 일부가 아니다.
- 클러스터는 “운영을 위한 실행 환경”의 일부다.

즉, 클러스터 관리는 데이터 흐름이 아니라 시스템 생명주기와 안정성의 문제다.

#### 2.2 클러스터 매니저의 역할

클러스터 매니저는 워커를 만들고, 유지하고, 문제가 생기면 되살리는 역할을 맡는다.
이 역할은 “요청을 어떻게 처리하는가”가 아니라 “요청을 처리할 수 있는 실행 단위를 어떻게 유지하는가”에 해당한다.

따라서 클러스터 매니저는 다음을 책임진다.

- 워커의 시작과 종료
- 워커의 상태 감시
- 비정상 종료 시 재기동
- 운영 신호에 따른 질서 있는 종료 흐름

#### 2.3 워커 간 통신과 동기화

멀티 워커 환경에서는 워커 간 상태 동기화와 통신이 필요할 수 있다.
이때 중요한 점은 “요청 처리 로직과 통신 구조”를 혼합하지 않는 것이다.

통신은 통신이고, 요청 처리는 요청 처리다.
통신 구조는 표준화할 수 있지만, 요청 처리 흐름을 통신 구조에 종속시키면 어댑터의 독립성이 붕괴한다.

#### 2.4 워커 구성 모델 (Worker Placement Model)

Bunner는 멀티 어댑터를 전제로 하므로, 워커 배치는 “프로세스 수”가 아니라 “어댑터 조합”의 문제를 포함한다.
그러나 이 문제를 런타임에서 해결하려 하면, 결국 운영 토폴로지(Host/포트/프록시)를 프레임워크가 통제하려는 형태가 된다.
Bunner는 이를 하지 않는다.

따라서 워커 배치는 사용자 설정으로 결정되며, 프레임워크는 다음 두 모델을 모두 지원한다.

- **Model A: All-Adapters-Per-Worker**
  - 모든 워커가 동일한 어댑터 집합을 가진다.
  - 가장 단순하고 직관적인 기본 모델이다.

- **Model B: Worker Groups**
  - 워커 그룹마다 어댑터 집합을 다르게 구성할 수 있다.
  - 어댑터별 워커 수(또는 그룹별 워커 수)를 통해 리소스/성능 전략을 사용자 의도대로 분리할 수 있다.

#### 2.5 빌드타임 판정 경계 (What Bunner Can Prove)

프레임워크가 개입할 수 있는 것은 “판정 가능한 모순”뿐이다.
운영 토폴로지(동일 Host, 포트 공유, 프록시 라우팅 등)는 사용자 설정 영역이며 프레임워크가 판정하지 않는다.

CLI는 `Common` 및 각 Adapter가 제공하는 정적 명세(Manifest)와 사용자 설정을 기반으로 다음만을 빌드타임에 판정한다.

- **의존 위반:** A가 B에 의존하는데(A dependsOn B), A와 B가 서로 다른 워커 그룹으로 분리된 경우 → 빌드타임 에러
- **결합 결정 불가:** 결합 대상이 명시되지 않았고 후보가 복수인 경우 → 빌드타임 에러
- **정적 불변성 위반:** 실행 이후 동적 등록/동적 결합을 유발하는 설정 → 빌드타임 에러

이 원칙은 “추측 금지”를 유지한다.
Bunner는 자동 탐색, 우선순위 기반 선택, 암묵적 보정을 제공하지 않는다.

---

### 3. 생명주기 및 상태

#### 3.1 생명주기 관리의 목적

Bunner는 “시작부터 종료까지 무엇이 언제 실행되는지”가 명확해야 한다고 본다.
이는 단순한 편의가 아니라, 운영 시나리오(배포, 롤링 업데이트, 장애 대응, 종료 처리)를 예측 가능하게 만드는 핵심 장치다.

#### 3.2 종료 처리와 배수(Draining)

Bunner는 종료를 “갑자기 꺼짐”으로 취급하지 않는다.
종료는 명시적으로 다음 단계를 포함한다.

- 새 요청의 수신 중단
- 진행 중 작업의 배수 처리
- 리소스 정리 및 종료

이 구조는 트래픽이 있는 서버에서 질서 있는 운영을 가능하게 한다.

#### 3.3 어댑터에 대한 라이프사이클 신호

Bunner는 어댑터에게 요청 처리 방식이나 내부 실행 흐름을 지시하지 않는다.
하지만 운영을 위해서는 어댑터가 “언제 열고, 언제 닫는지”는 제어해야 한다.

따라서 코어가 어댑터에게 보내는 것은 오직 “생명주기 신호”뿐이다.

이 신호는 세 단계로 확정된다.

- 수신 시작
- 새 요청 수신 중단
- 최종 종료 및 자원 해제

이로써 “수신 중단”과 “최종 종료”가 구분되어 운영 정합성이 확보된다.

---

### 4. 의존성 및 스코프

#### 4.1 기본 철학

Bunner의 기본 스코프는 단일 인스턴스 유지에 기반한다.
런타임은 새로 조립하지 않고, 이미 조립된 것을 사용한다.

#### 4.2 조회 중심 접근

런타임은 “생성”이 아니라 “조회”를 중심으로 움직인다.
즉, 실행 중에 어떤 것을 새로 만들어 해결하는 방식은 허용되지 않는다.

이 원칙은 성능과 예측 가능성 측면에서 중요하다.

#### 4.3 요청 단위 스코프에 대한 태도

요청 단위로 객체를 새로 만드는 것은 비용이 크고, 런타임 변동성을 증가시킨다.
따라서 요청 단위 스코프를 무제한으로 허용하지 않는다.

요청 단위 스코프가 필요하다면, 이를 런타임 동적 생성으로 풀지 않고 “설계 단계에서 이미 정해진 방식”으로 처리해야 한다.

---

### 5. 설정 관리

#### 5.1 설정은 실행 이전 단계다

Bunner에서 설정은 “애플리케이션의 일부”가 아니다.
설정은 애플리케이션이 만들어지기 전에 반드시 확정되어야 하는 전제다.

즉, 설정 로딩은 실행 전 단계에서 수행된다.

#### 5.2 런타임 환경 로딩과 즉시 실패

설정은 배포 환경에서 런타임에 주입될 수 있다.
따라서 설정 로딩은 다음 원칙을 따른다.

- 런타임에서 환경을 읽는다.
- 필요한 값이 없거나 유효하지 않다면 즉시 실패한다.
- 실패 시 시스템은 시작하지 않는다.

“시작 후 문제를 발견”하는 방식은 금지된다.

#### 5.3 설정 검증의 책임

설정은 타입 안정성과 검증 가능성을 가져야 한다.
검증은 로딩과 동시에 수행되어야 하며, 애플리케이션 생성 단계로 지연되면 안 된다.

---

### 6. 외부 연결 및 맥락

#### 6.1 어댑터의 지위

어댑터는 시스템의 관문이며, 독립된 실행 주체다.
Bunner의 코어는 어댑터의 요청 처리 모델을 통제하지 않는다.

어댑터는 다음을 소유한다.

- 요청 수신
- 컨텍스트 생성
- 컨텍스트 가공
- 요청 처리 실행
- 응답 생성 및 전송
- 동시성 및 백프레셔 정책

코어는 어댑터 내부 흐름을 지배하거나 개입하지 않는다.

#### 6.1.1 어댑터 의존과 결합 (Dependency & Attachment)

어댑터는 “독립된 실행 주체”라는 지위를 유지한다.
다만 독립성은 “단독 실행만 가능”을 의미하지 않는다.

멀티 어댑터 환경에서 어댑터는 다음 두 형태 중 하나(또는 둘 다)를 선택적으로 제공할 수 있다.

- **Standalone Mode**
  - 어댑터가 스스로 리스너/서버를 생성하고 구동한다.
  - 외부 어댑터를 지정하지 않아도 동작할 수 있다.
  - Standalone 가능 여부는 어댑터 구현의 책임이며, 프레임워크가 이를 추론하거나 보정하지 않는다.

- **Dependent Mode**
  - 어댑터가 다른 어댑터를 “매개체”로 재사용한다.
  - 이때 의존은 플러그인/하위 개념이 아니라, 실행 매개체(호스트/리스너/전송 계층) 공유를 위한 “명시적 결합”이다.
  - Dependent Mode를 사용할 경우, 의존 대상은 반드시 설정에서 명시되어야 한다.
  - 프레임워크는 자동 탐색이나 임의 선택을 수행하지 않는다.

Bunner가 관리하는 것은 오직 다음뿐이다.

- **의존(Dependency):** 어떤 어댑터가 어떤 어댑터를 필요로 하는지의 정적 관계
- **결합(Attachment):** 특정 어댑터가 어떤 매개체(다른 어댑터)에 붙는지의 명시적 결정

그 외(동일 Host 구성, 포트/프록시 토폴로지, 운영 라우팅 등)는 사용자 설정 영역이며 프레임워크가 검증하거나 힌트를 제공하지 않는다.

#### 6.2 코어의 역할

코어가 어댑터에게 제공하는 것은 다음뿐이다.

- 생명주기 신호
- 공통 규약(필요한 경우)

즉, 코어는 어댑터를 “운영적으로 제어”하되, “요청 처리적으로 통제”하지 않는다.

---

### 7. 실행 파이프라인

#### 7.1 선언적 파이프라인 정의 (Declarative Definition)

프레임워크는 중앙 엔진을 돌리지 않는다. 대신, 어댑터 개발자가 자신의 실행 흐름(라이프사이클)을 프레임워크에게 명확하고 심플하게 알려줄 수 있는 **'Simple Pipeline Definition API'**를 제공한다.

어댑터 개발자는 이 API를 통해 `Middleware -> Guard` 등의 실행 순서와 조건을 직관적으로 명세한다.

#### 7.2 어댑터별 정적 구성 (Per-Adapter Static Composition)

파이프라인은 CLI가 생성하되, **각 어댑터의 정의(Definition)**에 맞춰 독립적인 함수 체인으로 만들어진다.

- **Adapter-Owned Execution**: 생성된 파이프라인 코드는 어댑터 소유다. 어댑터는 이 함수 체인을 자신의 이벤트 루프 안에서 직접 실행하며, 실행 시점과 방식에 대한 완전한 통제권을 가진다.

#### 7.3 파이프라인 시각화 (Pipeline DX)

어댑터별로 상이한 파이프라인 구조를 개발자가 명확히 파악할 수 있도록, CLI는 빌드 타임에 **파이프라인 구조도(Graph)**나 디버깅 메타데이터를 제공하여 가시성을 확보한다.

### Pipeline & Filters (from Adapter Spec)

어댑터가 요청을 받아 비즈니스 로직으로 전달할 때 거쳐야 하는 **표준 실행 파이프라인(Execution Pipeline)**을 구성할 수 있는 API와 타입을 제공한다.

- **Declarative Pipeline Definition (선언적 파이프라인 정의):**
  - 어댑터 개발자가 `Middleware -> Guard -> Handler`로 이어지는 실행 흐름을 직관적으로 정의할 수 있는 **Simple Pipeline Definition API**를 제공한다.
  - 런타임 엔진이 존재하지 않으며, 이 정의를 바탕으로 CLI가 최적화된 코드를 생성한다.

- **Unified Error Filter Chain (단일화된 에러 필터 체인):**
  - 모든 예외 처리는 **Error Filter**가 담당한다는 단일 원칙을 제공한다.
  - 어댑터 구현체는 별도의 예외 처리 로직(try-catch)을 작성할 필요 없이, 프레임워크가 생성한 필터 체인을 통해 모든 예외가 표준 결과(Result)로 변환됨을 보장받는다.

### Runtime Base (from AOT/AST Spec)

Core는 AOT 컴파일러가 생성한 코드를 실행하는 최소한의 런타임 환경을 제공한다.

- **No Dynamic Logic:**
  - Core에는 동적 모듈 로딩, 런타임 의존성 해결 등의 로직이 존재하지 않는다.
  - 모든 연결과 구성은 이미 완료된 상태로 Core에 전달된다.

- **Execution Context Propagation:**
  - 컴파일러가 주입한 구조적 실행 컨텍스트 정보를 런타임에 유지하고 전파한다.
  - 에러 발생 시나 로그 출력 시, 이 정보를 통해 정확한 실행 위치와 경로를 파악할 수 있도록 돕는다.

### Lifecycle Management (from DI Spec)

DI와 직접적으로 관련된 런타임 로직은 거의 없으나, 라이프사이클 관리와 연동된다.

- **Lifecycle Hooks:**
  - 생성된 인스턴스들의 초기화(`onModuleInit`) 및 종료(`onModuleDestroy`) 시점을 관리한다.
  - 의존성 그래프의 역순으로 종료 훅을 실행하여 안전한 리소스 해제를 보장한다.

### Default Error Handling (from Error Handling Spec)

- **Default Filter Implementation:**
  - 제거 불가능한 내장 필터(Default Framework Error Filter)를 구현하여 제공한다.
  - `Unknown Error`, `Out of Memory` 등의 치명적인 상황에서도 최소한의 JSON 응답을 보장한다.

---

### 8. 에러 처리

#### 8.1 모든 것은 필터다 (Unified Filter Chain)

'Safety Net', 'Panic Handler' 등 복잡한 제 3의 개념을 두지 않는다. 에러 처리의 모든 단계는 **'Error Filter'**로 통일된다.

#### 8.2 기본 프레임워크 에러 필터 (Default Framework Error Filter)

필터 체인의 가장 마지막에는 프레임워크가 제공하는 **Default Error Filter**가 위치한다.

- 이것이 시스템의 **'Last Resort (최후의 보루)'** 역할을 수행한다.
- 사용자 정의 필터가 처리하지 않고 흘려보낸(Pass-through) 예외나, 필터 자체에서 발생한(Throw) 예외는 최종적으로 이 기본 필터가 포착한다.
- 기본 필터는 무조건 표준 실패(Result)로 변환하여, 어댑터가 항상 일관된 응답 처리를 할 수 있도록 보장한다.

#### 8.3 위임 없는 흐름 (No Delegation)

'위임'이나 '복구' 같은 복잡한 흐름은 없다. 단순한 Fall-through 구조다.

- 예외 발생 -> 필터 1 -> 필터 2 -> ... -> **Default Filter** -> Result.
- 필터가 잡아서 Result를 내놓으면 성공이고, 필터가 잡지 못하거나 에러를 뱉으면 다음(결국은 Default) 필터가 잡는다.

---

### 9. 기능 런타임 및 확장 정책

#### 9.1 엔진 교체 금지

Bunner 코어의 실행 메커니즘은 교체 대상이 아니다.
프레임워크의 핵심 런타임이 사용자에 의해 갈아끼워지는 순간, 시스템은 더 이상 예측 가능하거나 판정 가능하지 않게 된다.

따라서 엔진 교체는 불허한다.

#### 9.2 구현 교체 전면 허용

반면, 사용자가 작성하는 구성 요소 구현은 전면 허용된다.
사용자는 필요한 모든 미들웨어, 가드, 에러 필터 구현을 제공할 수 있다.

코어는 그것을 실행하는 “방식”을 바꾸는 것이 아니라, 실행 가능한 “형태”만 요구한다.

#### 9.3 정책 교체 전면 허용

기본 정책은 존재할 수 있지만, 사용자는 훅과 설정을 통해 정책을 바꿀 수 있다.
정책 교체는 시스템의 목적(유연성)을 위해 허용되며, 엔진 교체와 혼동되지 않아야 한다.

---

## 📜 Logger - @bunner/logger

- Bun.stringWidth 사용 검토

---

## 🛡️ Error Filter (Unified Exception Handler)

Bunner의 Error Filter는 예외 흐름(Exception)을 정규 데이터 흐름(Result)으로 전환하는 유일한 장치다. 별도의 안전망(Safety Net) 개념 없이, 필터 체인만으로 시스템의 안정성을 확보한다.

### Key Philosophy & Features

- **Success or Fall-through (성공 또는 통과):**
  - 필터는 예외를 포획하여 `Result`로 변환을 시도한다.
  - 만약 변환할 수 없거나 필터 내부 로직에서 에러가 발생하면, 즉시 **다음 필터(Next Filter)로 제어권이 넘어간다(Throwing / Fall-through).**
  - 어떤 필터도 처리하지 못한 예외는 최종적으로 **Default Framework Error Filter**에 도달하여, 무조건적인 시스템 에러 `Result`로 변환된다.

- **Unified Responsibility (책임 통합):**
  - '도메인 에러 필터'와 '시스템 패닉 핸들러'를 구분하지 않는다. 모든 것은 우선순위가 다른 필터일 뿐이다.
  - 사용자는 비즈니스 로직에 맞는 필터를 앞단에 배치하여 도메인 예외를 처리하고, 프레임워크는 뒷단에서 시스템 안정성을 책임진다.

### ⚙️ CLI - @bunner/cli

- **Auto-Generated Try-Catch Guard:**
  - AOT 컴파일러는 핸들러와 필터 주변에 최적화된 `try-catch` 블록을 자동으로 생성한다.
  - 개발자가 명시적으로 `try-catch`를 작성하지 않아도, 예외 발생 시 즉시 가장 가까운 필터 체인으로 점프하도록 제어 흐름을 연결한다.

### 📐 Common - @bunner/common

- **Simple Filter Interface:**
  - `catch(exception): Result | void` 형태의 단순한 인터페이스를 제공한다.
  - `Result`를 반환하면 처리 완료, 아무것도 반환하지 않거나 에러를 던지면 다음 단계로 넘어가는 명확한 계약을 가진다.

### 💎 Core - @bunner/core

- **Default Framework Error Filter:**
  - 사용자가 제거할 수 없는 **내장 필터**를 제공한다.
  - `Unknown Error`, `Out of Memory` 등 예측 불가능한 패닉 상황에서도 최소한의 로그를 남기고, 클라이언트에게 유효한 JSON 응답을 줄 수 있는 최후의 보루 역할을 수행한다.

---

## 📖 Docs - @bunner/docs

`@bunner/docs`는 Bunner 생태계에서 서비스의 규약을 외부로 노출하기 위한 **독립형 정적 명세 추출 패키지**이다. 프레임워크의 실행 모델이나 빌드 파이프라인(Artifact)에 포함되지 않으며, 문서화가 필요한 시점에 별도로 구동되어 프로젝트를 스캔하는 독립적 유닛이다.

### 🎯 핵심 원칙

- **Zero Runtime Overhead:** 문서화를 위해 작성된 모든 데코레이터와 메타데이터는 런타임 코드에 어떠한 영향도 주지 않으며, 서비스 로직에서 절대 참조되거나 재활용되지 않는다.
- **Strict Separation:** 비즈니스 로직 패키지와 완전히 분리되어 동작한다. 개발 단계에서는 마커 역할을 수행하고, 문서 추출 시점에만 `@bunner/docs` 스캐너에 의해 소비된다.
- **Explicit Declaration:** 자동 추론에 의한 불확실한 정보 생성을 배제한다. 개발자가 명시적으로 작성한 데코레이터 정보만을 정본으로 간주하며, 작성되지 않은 영역은 최소한의 구조적 정보(Path, Method 등)만 노출한다.
- **Adapter-Centric Specification:** 하나의 공통 로직이더라도 결합된 어댑터(HTTP, WebSocket 등)의 물리적 특성과 엔드포인트에 맞춰 프로토콜별 표준 명세(OpenAPI, AsyncAPI 등)를 개별적으로 출력한다.

### 🧰 주요 기능

- **AOT Static Scanner:** 소스 코드를 정적으로 분석하여 `@Api` 계열 마커가 부착된 클래스, 메서드, DTO를 인덱싱하고 구조화한다.
- **Manual Enhancement Decorators:** `NestJS`의 Swagger와 유사한 선언형 인터페이스를 제공하여 명칭, 설명, 예시값 등을 기술할 수 있게 한다.
- **Multi-Protocol Export:** - **HTTP:** OpenAPI(Swagger) 호환 JSON/YAML 명세 생성.
- **WebSocket/Queue:** AsyncAPI 표준 명세 생성.
- **Isolated Execution:** `bunner build`와 무관하게 사용자가 원할 때만 구동하여 최신 명세를 추출하는 독립적 프로세스를 제공한다.

---

## 🔌 HTTP Adapter - @bunner/http-adapter

`@bunner/http-adapter`는 Bunner의 실행 모델을 HTTP라는 물리 프로토콜 위에 투영하는 번역 계층이다.  
이 패키지는 HTTP 서버 프레임워크가 아니며, Bunner가 정의한 불변 실행 모델과 파이프라인 규약을 HTTP 환경에서 그대로 유지하는 것을 목적으로 한다.

HTTP 어댑터의 역할은 다음 흐름으로 요약된다.

- HTTP 요청을 수신한다.
- 요청으로부터 Raw Body / Query / Params를 추출하여 표준 Context를 생성한다.
- 어댑터가 소유한 이벤트 루프 안에서, CLI가 생성한 정적 파이프라인을 실행한다.
- 실행 결과를 Result 또는 예외 흐름으로 수신한다.
- 이를 HTTP 응답으로 환원한다.

이 과정에서 어댑터는 요청의 의미를 해석하지 않는다.  
의미 해석은 선택적이며, 파이프라인 구성에 의해 결정된다.

---

### Raw Input as a First-Class Concept

HTTP 어댑터는 Body, Query, Params를 항상 Raw 형태로 제공한다.

- Body는 파싱 여부와 무관하게 bytes 또는 string 형태로 존재한다.
- Query는 URL에 포함된 문자열 집합으로 항상 접근 가능하다.
- Params는 라우터의 경로 매칭 과정에서 생성되며, 별도의 파싱 단계를 요구하지 않는다.

이로 인해 Transformer나 Validator를 사용하지 않는 경우에도,  
사용자는 HTTP 입력 데이터에 직접 접근하여 로직을 작성할 수 있다.

---

### Parsing as Optional Middleware

HTTP 어댑터는 JSON, form-data, multipart 등의 전송 형식 파싱 로직을 기본 동작으로 숨기지 않는다.  
대신, 이러한 기능을 HTTP 어댑터가 제공하는 미들웨어 형태로 제공한다.

- 이 미들웨어들은 HTTP 어댑터가 소유한다.
- 사용자는 모듈/어댑터 설정에서 이를 파이프라인에 명시적으로 등록한다.
- 등록하지 않을 경우, 입력 데이터는 Raw 상태로 유지된다.

파싱은 필수 단계가 아니라, 해석 수준을 한 단계 올리는 선택이다.

---

### Separation of Transport and Semantics

HTTP 어댑터가 제공하는 파싱 미들웨어는 전송 계층까지만을 다룬다.

- JSON 파싱
- form decoding
- multipart 분해

DTO 바인딩, 타입 변환, 검증, 도메인 규칙 적용은  
Transformer, Validator, 그리고 사용자 로직의 책임이다.

이 분리를 통해 HTTP 어댑터는 번역 계층에 머물고,  
도메인 로직은 프로토콜로부터 독립성을 유지한다.

---

### Status Code Translation

HTTP 어댑터는 Result를 HTTP 응답으로 환원하기 위한  
기본 상태 코드 매핑을 제공한다.

이 매핑은 관례적 기본값일 뿐이며, 사용자는 이를 재정의할 수 있다.  
중요한 원칙은 상태 코드가 도메인에 존재하지 않고,  
어댑터의 번역 테이블에만 존재한다는 점이다.

---

### Failure Semantics

HTTP 어댑터는 실패를 완화하거나 추측으로 보정하지 않는다.

- 도메인 실패는 Result로 반환된다.
- 예외는 Error Filter 체인을 통해 표준 시스템 실패로 환원된다.

HTTP 계층에는 별도의 예외 처리 규칙이 존재하지 않으며,  
프레임워크가 정의한 단일 실패 모델을 그대로 따른다.

---

## 🔌 Websocket Adapter - @bunner/websocket-adapter

`@bunner/websocket-adapter`는 WebSocket 프로토콜의 요청 수신, 연결 수명주기, 메시지 처리 흐름을 소유하는 독립 어댑터다.
코어는 WebSocket의 이벤트 루프/백프레셔/메시지 모델을 통제하지 않으며, 어댑터가 자신의 실행 방식을 완전히 소유한다.

### 🎯 핵심 목표

- WebSocket을 “HTTP의 부속”으로 취급하지 않는다.
- WebSocket은 독립 어댑터로서 스탠드얼론 실행이 가능해야 한다.
- 동시에, 운영/효율을 위해 HTTP 어댑터를 매개체로 재사용하는 결합도 허용한다.
- 프레임워크는 의존과 결합만 관리하며, Host/포트/프록시 토폴로지는 사용자 설정 영역이다.

### 1) 실행 형태: Standalone vs Dependent

WebSocket 어댑터는 다음 두 실행 형태 중 하나(또는 둘 다)를 제공할 수 있다.

#### 1.1 Standalone Mode

- WebSocket 어댑터가 스스로 서버/리스너를 생성하여 구동한다.
- HTTP 어댑터가 전혀 없는 “WebSocket-only 서버” 구성이 가능해야 한다.
- Standalone 가능 여부와 구체 구현은 어댑터의 책임이다.

#### 1.2 Dependent Mode (HTTP 매개체 재사용)

- WebSocket 어댑터가 특정 HTTP 어댑터를 매개체로 재사용하여 결합한다.
- 이때 “의존”은 계층 구분(1/2급)이나 플러그인 개념이 아니라, 실행 매개체 공유를 위한 명시적 결합이다.

중요한 규칙:

- Dependent Mode를 사용한다면, 의존 대상 HTTP 어댑터는 설정에서 반드시 명시되어야 한다.
- HTTP 어댑터가 여러 개 등록될 수 있으므로, 자동 탐색/자동 선택은 금지한다.
- 의존 대상을 명시하지 않은 상태에서 후보가 복수면 빌드타임 에러가 발생해야 한다.

### 2) 파이프라인과 데이터 모델

WebSocket은 HTTP처럼 “요청 1회 = 응답 1회”가 아니다.
따라서 WebSocket 어댑터는 다음을 전제로 한다.

- 메시지 단위 처리(프레임/이벤트)와 연결 단위 처리(연결/해제)는 분리된 수명주기를 가진다.
- “반드시 Result로 응답” 같은 단일 반환 규칙을 강제하지 않는다.
- 다만 도메인 실패를 표현하는 표준 형태(Result/Domain Error Contract)와 시스템 장애(throw) 경계는 상위 원칙을 따른다.
  - 도메인 실패는 표준 실패 컨테이너로 표현될 수 있어야 한다.
  - 시스템 장애는 throw 경로로 이탈하며, 최후 안전망에서 격리/로깅된다.

### 3) Cluster Manager와의 관계 (배치 모델만 연결)

WebSocket 어댑터는 클러스터 배치 모델을 강제하지 않는다.
배치는 사용자 설정이며, 프레임워크는 판정 가능한 모순만 빌드타임에 드러낸다.

- 워커가 모든 어댑터를 포함하는 구성(All-Adapters-Per-Worker)을 지원한다.
- 워커 그룹별로 어댑터를 분리하는 구성(Worker Groups)을 지원한다.
- Dependent Mode를 사용하는 경우, 의존 대상과 같은 워커 그룹에 배치되어야 한다.
  - (A dependsOn B) 관계가 서로 다른 워커 그룹으로 분리되면 빌드타임 에러가 발생해야 한다.

### 4) 범위 고정 (Non-Goals)

`@bunner/websocket-adapter`는 다음을 포함하지 않는다.

- Host/포트/프록시 토폴로지의 검증 또는 힌트 제공
- 런타임 자동 탐색/자동 결합/우선순위 기반 선택
- WebSocket 위에 특정 상위 프로토콜(Socket.IO 등)을 내포하는 단일 거대 어댑터로의 통합
  - 상위 프로토콜은 별도 어댑터로 분리하며, 필요한 경우 동일한 “명시적 의존/결합” 규칙을 따른다.

---

## 🔌 Socket IO Adapter - @bunner/socket.io-adapter

`@bunner/socket.io-adapter`는 Socket.IO 프로토콜을 구동하기 위한 독립 어댑터다.
Socket.IO는 WebSocket과 동일한 계층의 대상이 아니며, 단순 전송 수단이 아니라
연결 수명주기, 이벤트 모델, 세션 상태를 포함한 애플리케이션 프로토콜이다.

따라서 Socket.IO는 `@bunner/websocket-adapter`의 확장이나 부속으로 취급되지 않으며,
별도의 어댑터로 명확히 분리된다.

### 🎯 기본 입장

- Socket.IO는 **어댑터로서 독립적**이다.
- 프레임워크는 Socket.IO의 내부 동작, 상태 모델, 운영 전략에 관여하지 않는다.
- Bunner가 관리하는 것은 오직 **의존(Dependency)** 과 **결합(Attachment)** 이다.

### 1) 실행 형태: Standalone 과 Dependent

Socket.IO 어댑터는 다음 두 실행 형태 중 하나(또는 둘 다)를 제공할 수 있다.

#### 1.1 Standalone Mode

- Socket.IO 어댑터가 스스로 실행 매개체를 포함하여 단독으로 동작한다.
- 다른 어댑터(HTTP, WS 등)를 필수로 요구하지 않는다.
- Standalone 가능 여부는 Socket.IO 어댑터 구현의 책임이며,
  프레임워크는 이를 추론하거나 강제하지 않는다.

#### 1.2 Dependent Mode (HTTP 매개체 재사용)

- Socket.IO 어댑터가 특정 HTTP 어댑터를 매개체로 재사용한다.
- 이때 의존은 계층 구분이나 플러그인 개념이 아니라,
  실행 매개체(요청 엔트리/연결 수립 지점)를 공유하기 위한 **명시적 결합**이다.

중요한 규칙:

- Dependent Mode를 사용하는 경우, 의존 대상 HTTP 어댑터는 설정에서 **반드시 명시**되어야 한다.
- HTTP 어댑터가 여러 개 등록될 수 있으므로, 자동 탐색이나 자동 선택은 허용되지 않는다.
- 의존 대상을 명시하지 않았고 후보가 복수일 경우, 이는 **빌드타임 에러**로 처리된다.

### 2) WebSocket 어댑터와의 관계

- Socket.IO는 WebSocket 어댑터의 상위/하위 개념이 아니다.
- Socket.IO 어댑터는 WebSocket 어댑터에 의존하지 않으며, 병렬적인 독립 어댑터로 취급한다.
- 두 어댑터는 필요에 따라 동일한 매개체를 공유할 수 있지만,
  이는 어댑터 간 명시적 의존/결합으로만 표현된다.

### 3) 상태, 확장, 외부 어댑터

- Socket.IO의 상태 관리(네임스페이스, 룸, 브로드캐스트 등)는
  Socket.IO 어댑터의 책임 영역이다.
- 멀티 워커 또는 분산 환경에서의 동작 보장은
  Socket.IO 어댑터가 선택적으로 외부 어댑터를 결합함으로써 해결한다.
- 프레임워크는 이러한 외부 어댑터의 필요성, 설치 여부, 운영 적합성을 판단하지 않는다.

의존이 필요한 경우, 해당 외부 어댑터는 **명시적 의존 관계**로만 표현된다.
의존이 명시되었으나 충족되지 않으면, 이는 빌드타임 에러로 처리된다.

### 4) Cluster Manager와의 관계

- Socket.IO 어댑터는 클러스터 배치 모델을 강제하지 않는다.
- 모든 워커가 Socket.IO 어댑터를 포함하는 구성과,
  특정 워커 그룹에만 포함하는 구성을 모두 허용한다.
- 단, Socket.IO 어댑터가 다른 어댑터에 의존하는 경우,
  해당 의존 대상과는 **동일 워커 그룹**에 배치되어야 한다.
  이 규칙을 위반하면 빌드타임 에러가 발생한다.

### 5) 범위 고정 (Non-Goals)

`@bunner/socket.io-adapter`는 다음을 포함하지 않는다.

- Host/포트/프록시/라우팅/세션 스티키니스에 대한 검증 또는 가이드
- 런타임 자동 탐색, 자동 결합, 암묵적 우선순위 규칙
- WebSocket 또는 HTTP 어댑터 내부로의 기능 흡수

이 모든 영역은 사용자 설정 및 운영 책임이며,
프레임워크는 명시적으로 선언된 의존과 결합만을 관리한다.

---

## 💧 Drizzle ORM - @bunner/drizzle-orm

`@bunner/drizzle-orm`은 Drizzle ORM을 사용하는 데 필요한 **데코레이터, 리포지토리 패턴, 그리고 전용 코드 생성기**를 독자적으로 제공하는 **독립 확장 패키지**다. 프레임워크 코어(`common`, `cli`)는 Drizzle의 존재를 알지 못하며, 오직 이 패키지가 제공하는 인터페이스와 규약을 통해 연동된다.

### Key Philosophy & Features

- **Cohesive Class-Based Schema (응집된 클래스 기반 스키마):**
- Drizzle의 분리된 테이블 정의와 관계(Relations) 설정을 **엔티티 클래스 내부로 통합**한다.
- `@Entity`, `@Column`, `@ManyToOne` 등의 데코레이터는 **이 패키지 내부에 정의**되며, 런타임 로직이 없는 순수 마커(Marker)로 작동한다.

- **Package-Owned Code Generation (패키지 소유의 코드 생성):**
- 엔티티 클래스를 Drizzle 네이티브 스키마(`pgTable` 등)로 변환하는 AOT 컴파일 로직은 CLI 내장이 아니라, **이 패키지가 제공하는 플러그인**에 포함된다.
- `bunner build` 프로세스는 이 패키지가 제공한 생성기를 호출할 뿐, 구체적인 변환 및 마이그레이션 아티팩트 생성 로직은 이 패키지가 전담한다.

- **Exposed Drizzle Power (Drizzle 본연의 기능 노출):**
- Drizzle의 쿼리 빌더를 추상화 계층 뒤에 숨기지 않는다.
- **Repository**는 Drizzle 인스턴스에 접근하는 표준화된 경로를 제공하며, 사용자가 Drizzle의 유연한 쿼리 기능을 100% 활용할 수 있도록 보장한다.

- **DataMapper Architecture (데이터 매퍼 아키텍처):**
- 엔티티 클래스는 비즈니스 로직이 없는 순수 데이터 객체(POJO)로 유지된다.
- 데이터 접근은 Repository로 분리되어 도메인 모델과 영속성 계층의 관심사를 명확히 분리한다.
