# 라우터 분석 보고서

## 1. 개요

현재 라우터는 매우 정교하고 다양한 최적화 기법이 적용되어 있지만, 몇 가지 잠재적인 문제점과 개선의 여지가 있습니다.

> **운영 전제**: 본 프로젝트는 Bun 런타임을 대상으로 하며, 라우터는 `build()` 완료 시점 이후 완전히 불변(immutable) 상태로 고정된다. 런타임에서 라우트를 수정하거나 삭제하는 기능뿐 아니라, 이미 활성화된 인스턴스를 새 빌드로 교체(swap)하는 행위도 허용하지 않는다. 새로운 라우트 구성이 필요하면 애플리케이션을 재시작·재배포하여 초기화 단계에서만 빌드 산출물을 주입한다.

---

## 2. 문제점 및 부족한 점

### 2.1. 캐시 관련 문제

#### 2.1.1. 캐시 무효화의 복잡성 및 과잉 무효화

- **문제점**: 새로운 라우트 추가 시 `invalidateCacheForRoute`, `applyCacheInvalidation` 로직이 복잡하고, `prefix` 기반 무효화로 실제 영향 없는 캐시도 삭제됨
- **구체적 사례**: `/users/posts` 라우트 추가 시 `/users/profile` 캐시도 무효화 가능
- **보수적 설계 문제**: 와일드카드·옵셔널 파라미터가 많으면 쉽게 `kind: 'all'`로 전체 캐시 무효화 발생 (예: `/api/:version?/users/:id` 추가 시 `/api/v1/products/:id` 캐시도 무효화)
- **영향**: 캐시 히트율 감소, 성능 저하, 유지보수 어려움
- **타당성**: 높음 – 현재 구현이 prefix 기반 삭제를 사용한다는 코드 분석과 사례로 확인되어 재현 가능성이 큼.
- **우선순위**: 상 – 캐시 무효화는 전체 라우터 성능과 안정성에 직접 영향하며 대규모 서비스에서 즉시 체감됨.
- **적용 시 기대효과**: 불필요한 캐시 삭제 감소로 히트율 상승, 스타트업/배포 시 지연 감소, 운영 안정성 향상.

- ✅ 해결 (2025-11-18): 라우터가 `cacheVersion`/`CacheRecord.version`을 사용해 빌드마다 즉시 무효화하며 `options-behavior.test.ts`로 회귀를 감시함.

#### 2.1.2. LRU 정책의 불완전한 구현

- **문제점**: 현재 "LRU discipline via delete+set" 주석과 달리 조회(get) 시 재정렬하지 않아 실제 LRU 효과 제한적
- **영향**: 자주 조회되지만 최근 삽입되지 않은 항목이 먼저 제거됨
- **타당성**: 중간 – Map 기반 LRU가 조회 시 재삽입을 하지 않는 한계가 있으므로 논리적으로 맞지만, 캐시 크기가 작으면 체감이 적을 수도 있음.
- **우선순위**: 중 – 캐시 위주 워크로드에서만 의미 있으나 기능 정확성을 위해 개선 필요.
- **적용 시 기대효과**: 핫 라우트가 캐시에 오래 남아 재요청 처리 효율이 개선되고 예측 가능한 캐시 동작 확보.

- ✅ 해결 (2025-11-18): 조회 시 `touchCacheEntry`가 `delete`+`set`으로 항목을 재삽입해 실제 LRU 순서를 유지하도록 수정됨.

#### 2.1.3. 캐시 키 충돌 가능성

- **문제점**: `${method} ${normalizedPath}` 형식의 캐시 키가 이론적으로 충돌 가능
- **예시**: 메서드 값이 숫자인 경우 `"0 /api"` vs `"0" + " /api"` 구분 불가
- **영향**: 현재는 HttpMethod enum이 제한적이라 문제없으나, 향후 확장 시 위험
- **타당성**: 낮음 – 현재 enum 값이 상수라 실충돌 가능성은 작고, 경로 내 공백도 제한적임.
- **우선순위**: 하 – 단기적으로 리스크가 거의 없지만 장기 확장 시 재검토 필요.
- **적용 시 기대효과**: 키 포맷 개선 시 향후 기능 추가에도 캐시 충돌을 걱정하지 않아도 되어 유지보수 부담 감소.

- ✅ 해결 (2025-11-18): 캐시 키가 `${method}\0${normalized}` 포맷으로 고정되고 마지막 키 캐시로 문자열 할당을 줄임.

#### 2.1.4. CacheIndex의 메모리 누수 가능성

- **문제점**: `removeRecursive`에서 `noKeys` 변수 계산 후 실제 사용하지 않는 버그로 빈 노드가 정리되지 않음
- **코드 위치**: `cache-index.ts` 라인 92-99
- **영향**: 장기 실행 시 메모리 사용량 증가
- **타당성**: 높음 – 코드상 bool 반환을 활용하지 않아 정리가 누락되는 것이 확인됨.
- **우선순위**: 상 – 라우팅 캐시가 장시간 동작하는 서버에서 메모리 누수는 치명적일 수 있음.
- **적용 시 기대효과**: 루트 트리 크기 안정화로 메모리 사용량 예측 가능, 장기 서비스 안정성 확보.

- ✅ 해결 (2025-11-18): `CacheIndex.removeRecursive`가 빈 노드를 상위에서 제거하고 단위 테스트(`tests/unit/cache-index.test.ts`)로 검증됨.

### 2.2. 보안 관련 문제

#### 2.2.1. 파라미터 디코딩의 보안 취약점

- **문제점**: `decodeURIComponentSafe`가 `%2F` (슬래시)를 `/`로 디코딩하여 경로 구조 변경 가능
- **영향**:
  - 경로 기반 접근 제어 우회 가능
  - `/api/files/..%2F..%2Fetc%2Fpasswd` 같은 공격 패턴에 취약
  - 서명된 URL이나 해시 기반 검증 실패
- **타당성**: 높음 – 현재 구현이 ASCII 퍼센트 디코딩을 강제하므로 `%2F` 누락이 재현됨.
- **우선순위**: 상 – 보안 관련 결함은 즉시 대응 필요.
- **적용 시 기대효과**: 경로 우회 공격 차단 및 서명 기반 인증의 신뢰성 확보.

- ✅ 해결 (2025-11-17): `encodedSlashBehavior` 옵션으로 `%2F`/`%5C` 처리 정책을 고정하고 테스트로 보호함.

#### 2.2.2. `blockTraversal` 옵션의 제한적 보호

- **문제점**: `.`, `..` 세그먼트는 스택 기반 해소하지만, `%2e`, `%2e%2e` 같은 인코딩된 dot 세그먼트는 통과
- **영향**: 경로 순회 공격에 대한 불완전한 방어
- **타당성**: 중간 – 퍼센트 인코딩 처리 위치에 따라 실제 시스템에서도 재현 가능성이 높음.
- **우선순위**: 중 – 인가 레이어가 추가로 보호할 수 있으나 라우터 수준 방어가 필요.
- **적용 시 기대효과**: 디렉터리 트래버설 방지로 보안 심층 방어 강화.

- ✅ 해결 (2025-11-17): `normalizeAndSplit`이 `%2e` 변형을 dot 세그먼트로 간주하고 `blockTraversal` 옵션 테스트가 퍼센트 인코딩 케이스까지 포괄함.

### 2.3. 정규식 관련 문제

#### 2.3.1. 타임아웃 처리 모드 불일치

- **문제점**: `regexSafety.mode`가 `warn`이어도 `pattern-tester`의 타임아웃 래퍼가 항상 예외를 던져 경고 모드가 무력화됨
- **코드 위치**: `pattern-tester.ts` 라인 38
- **영향**: 운영 환경에서 일시적 성능 저하가 전체 요청 실패로 전파
- **타당성**: 높음 – 코드에서 `onTimeout` 이후 예외를 던지는 부분이 확인됨.
- **우선순위**: 상 – 잘못된 예외 처리로 SLA에 직접 영향을 줄 수 있음.
- **적용 시 기대효과**: 경고 모드가 의미를 지니며 부분적인 지연에도 서비스 지속 가능.

- ✅ 해결 (2025-11-17): `pattern-tester`가 warn 모드에서 경고만 남기고 브랜치 실패로 처리하며 error 모드에서만 예외를 던지도록 업데이트됨.

#### 2.3.2. 안전성 검사의 휴리스틱 한계

- **문제점**: `assessRegexSafety`가 단순 패턴 매칭으로 위험 패턴 탐지
  - `BACKREFERENCE_PATTERN`: `\\d+`, `\\k<name>` 탐지
  - `REPEATED_GROUP_PATTERN`: 중첩 수량자 탐지
- **한계**:
  - False positive: `(abc)+` 같은 안전한 패턴도 탐지 가능
  - False negative: `(a*)*`, `(a|a)*` 같은 재앙적 백트래킹 패턴 미탐지
  - 문자 클래스 내부의 복잡한 패턴 분석 불가
- **타당성**: 중간 – 휴리스틱 기반 탐지의 한계는 일반적으로 알려져 있으나 실제 문제 발생 여부는 데이터에 따라 다름.
- **우선순위**: 중 – 보안/성능 이슈지만 현재 타임아웃 보호가 있어 급박성은 낮음.
- **적용 시 기대효과**: 검증 정확도 상승으로 안전한 패턴 거부 감소, 위험 패턴 사전 차단 가능.

- ✅ 해결 (2025-11-18): `regex-guard.ts`가 길이, 역참조, 중첩 무한 수량자를 모두 검사하고 위험 샘플을 통합 테스트에 추가함.

#### 2.3.3. 파라미터 정규식의 앵커링 강제

- **문제점**: 자동으로 `^(?:...)$`로 래핑되어, 사용자가 앵커 포함 시 `^(?:^abc$)$` 같은 이중 앵커 생성
- **영향**: 의도하지 않은 매칭 실패 (이중 앵커는 절대 매칭 불가)
- **타당성**: 높음 – 구현이 항상 시작/끝 앵커를 추가하므로 사용자가 다시 넣으면 실패함.
- **우선순위**: 중 – 비교적 쉽게 문서화로 완화 가능하지만 사용자 혼란과 버그 소지가 큼.
- **적용 시 기대효과**: 패턴 작성 경험 개선, 기존 라우트 마이그레이션 시 호환성 확보.

- ✅ 해결 (2025-11-18): `regexAnchorPolicy`가 warn/error 정책을 제어하고, 앵커 검출 시 `normalizeParamPatternSource`가 자동으로 제거하며 경고/에러를 기록함.

### 2.4. 성능 관련 문제

#### 2.4.1. 정적 패스트 매치의 제한된 정규화

- **문제점**: `tryStaticFastMatch`는 대소문자와 trailing slash만 처리, 중복 슬래시나 dot 세그먼트 정규화 미수행
- **영향**: `//users`, `/./users` 같은 요청이 동적 매칭으로 폴백하여 성능 손실
- **타당성**: 중간 – 실제 요청이 비정규화된 경우에만 발생하며 기본 설정에 따라 빈도는 낮을 수 있음.
- **우선순위**: 중 – 정적 경로 비중이 높다면 투자 가치가 있으나 필수는 아님.
- **적용 시 기대효과**: 더 많은 요청을 정적 캐시에서 처리하여 평균 응답 시간 단축.

- ✅ 해결 (2025-11-18): `tryStaticFastMatch`가 `getNormalizedStaticProbe`/`segmentIsEncodedDot`로 연속 슬래시와 dot 세그먼트를 정규화하여 패스트 경로 히트율을 높임.

#### 2.4.2. 대소문자 무시 옵션의 성능 영향

- **문제점**: `caseSensitive: false` 설정 시 매 요청마다 `toLowerCase()` 변환 (이미 소문자인 경로도 포함)
- **영향**: 불필요한 검사 반복으로 성능 저하
- **타당성**: 낮음 – 소문자 여부를 한 번 검사 후 변환하도록 이미 구현되어 있어 비용이 제한적임.
- **우선순위**: 하 – 대규모 라우팅에서도 병목이 아니며 다른 최적화가 선행되어야 함.
- **적용 시 기대효과**: 미미하지만 불필요한 연산 감소로 CPU 절약.

- ✅ 해결 (2025-11-18): `ensureCaseNormalized`가 최초 대문자 검출 시에만 `toLowerCase()`를 호출하고, 정적 맵에 원본/소문자 키를 함께 등록해 반복 변환을 피함.

#### 2.4.3. 파라미터 우선순위 정렬의 한계

- **문제점**:
  - `PARAM_RESORT_THRESHOLD` 도달 전까지 비효율적 순서 유지
  - 히트 카운트가 2의 거듭제곱일 때만 정렬 (16, 32, 64...)
  - `paramHitCount`가 인메모리 전용으로 재시작 시 초기화
- **영향**: 특정 트래픽 패턴에서 차선의 성능 유지
- **타당성**: 높음 – 코드에서 임계값과 거듭제곱 조건이 확인되며 재시작 시 카운터 초기화됨.
- **우선순위**: 중 – 고트래픽 API에서 체감되지만 심각한 기능 오류는 아님.
- **적용 시 기대효과**: 인기 경로 매칭 속도 향상과 CPU 사용량 절감.

- ✅ 해결 (2025-11-18): 파라미터 브랜치 히트 카운트를 `Uint32Array`에 저장하고, 임계값·확률 기반 재정렬과 스냅샷 내보내기로 웜업 상태를 유지함.

#### 2.4.4. 와일드카드 suffix 계산의 중복 작업

- **문제점**: `getSuffixValue`가 매번 `ensureSuffixCache()` 확인 및 세그먼트 조인
- **영향**: 와일드카드 매칭이 많은 경로에서 미세한 오버헤드
- **참고**: `config.suffixSource`로 이미 구현되어 있으나 활용도 점검 필요
- **타당성**: 높음 – 현재 구현에서 매번 확인하는 로직이 성능에 영향을 미칠 수 있음.
- **우선순위**: 중 – 성능 최적화가 필요하지만 즉각적인 기능 장애는 아님.
- **적용 시 기대효과**: 중복 작업을 줄여 성능 개선 가능.

- ✅ 해결 (2025-11-18): 빌드 단계에서 suffix 오프셋/소스를 계산하고 `DynamicMatcher`가 캐시된 슬라이스만 참조해 런타임 조립 비용을 제거함.

### 2.5. 아키텍처 및 유지보수 문제

#### 2.5.1. `match-walker.ts`의 스택 기반 순회 방식

- **장점**: 깊은 재귀로 인한 스택 오버플로우 방지
- **단점**:
  - 재귀 버전 대비 코드 흐름 파악 어려움
  - 상태(`stage`) 명시적 관리로 디버깅 난이도 상승
  - 프레임마다 상태 객체 생성 및 push/pop 오버헤드 (미세)
- **타당성**: 중 – 가독성 어려움은 주관적이지만 복잡한 상태 기계가 maintenance cost를 높임.
- **우선순위**: 중 – 즉시 버그로 이어지지 않지만 신규 기여자 온보딩에 영향.
- **적용 시 기대효과**: 구조 개선 시 디버깅 시간 단축과 버그 유입 감소.

- ✅ 해결 (2025-11-18): `match-walker.ts`가 프레임 단계별 핸들러와 주석으로 리팩터링되어 유지보수성이 개선됨.

#### 2.5.2. 정적 압축(Compression) 지연 실행의 일관성 부족

- **문제점**: `compressStaticSubtree`가 `match` 메서드에서만 호출되어, 라우트 추가 후 즉시 구조 검사 시 비압축 상태 노출
- **영향**: 디버깅/테스트 시 예상치 못한 트리 구조, 일관성 없는 동작
- **타당성**: 높음 – 호출 지점이 `match`에 한정된 것이 코드로 확인됨.
- **우선순위**: 중 – 운영 중에는 문제없지만 도구/테스트 신뢰성에 영향.
- **적용 시 기대효과**: 일관된 데이터 구조로 진단 도구 정확도 향상.

- ✅ 해결 (2025-11-18): `build()` 파이프라인이 항상 `compress-static` 스테이지를 실행하고 런타임 지연 훅을 제거하여 add/build 직후 일관성을 확보함.

#### 2.5.3. 정적 압축의 메서드 경계 무시

- **문제점**: `collapseStaticNode`가 `methods.byMethod.size === 0`인 노드만 병합하여, 중간 노드에 다른 메서드 존재 시 압축 중단
- **예시**: `/a/b` (GET), `/a/b/c/d` (POST) - `/a/b/c/d` 경로 압축 불가
- **영향**: 메서드가 혼재된 라우트 구조에서 압축 효율 저하
- **타당성**: 중 – 재현 가능한 구조지만 메서드 다양성이 낮으면 체감이 제한됨.
- **우선순위**: 중 – 구조적 비효율이지만 기능 장애는 아님.
- **적용 시 기대효과**: 트리 깊이 감소로 매칭 비용과 메모리 사용이 줄어듦.

### 2.6. API 및 기능 부족

#### 2.6.1. 런타임 수정 비지원 설계

- **사실**: 라우터는 설계상 `add`/`addAll`만 제공하며, 삭제/교체 API는 물론 이미 빌드된 인스턴스를 런타임에 다른 스냅샷으로 대체하는 기능도 제공하지 않는다.
- **영향**: 멀티테넌트나 플러그인 환경에서는 새 구성을 빌더에서 다시 조립해도 이를 즉시 적용할 방법이 없으므로, 애플리케이션 전체를 재시작하거나 새 프로세스를 띄우는 식의 재배포 절차가 필수다. 자동화가 없다면 구성 변경마다 다운타임 위험이 커진다.
- **타당성**: 높음 – 명시적 제품 결정이므로 기능 추가 대신 빌드-불변·재배포 중심 파이프라인 최적화에 집중해야 함.
- **우선순위**: 중 – 해당 제약이 전략적 방향을 결정하므로 문서/도구 관점에서 조속히 명시 필요.
- **적용 시 기대효과**: 수정 불가 정책을 전제로 오프라인 빌드 검증, 배포 스크립트, 재시작 전략 등을 확립하면 혼란 없이 운영 정책을 일관되게 유지할 수 있음.

- ✅ 해결 (2025-11-18): README/PLAN이 빌드-불변 정책을 문서화하고 `generate-snapshot.ts` CLI 예제가 재배포 스크립트를 제공함.

#### 2.6.2. HTTP 메서드 호환성 옵션 부족

- **문제점**: `HEAD -> GET` 폴백 매칭, `OPTIONS` 자동 응답 미제공
- **영향**: 상위 레이어에서 반복 구현 필요, API 사용성 저하
- **타당성**: 중 – 기본 라우터는 의도적으로 단순화했을 가능성이 있으나 편의성 요구는 많음.
- **우선순위**: 중 – 프레임워크 통합 시 자주 요청되지만 필수 보안 이슈는 아님.
- **적용 시 기대효과**: 애플리케이션 레이어 코드 감소와 표준 호환성 향상.

- ✅ 해결 (2025-11-18): `headFallbackToGet`와 `autoOptions` 옵션이 도입되고, 허용 메서드 계산 로직 및 테스트가 추가됨.

#### 2.6.3. ':name\*' 문법 미지원

- **문제점**: `:name+`(1개 이상)는 지원하지만 `:name*`(0개 이상) 미지원
- **영향**: 다른 프레임워크의 라우트 정의 이식 어려움, 표현력 제한
- **타당성**: 높음 – 파서에 해당 토큰이 없어 실제 미지원임.
- **우선순위**: 중 – 마이그레이션 프로젝트에서 중요하지만 신규 설계에는 대체 문법 가능.
- **적용 시 기대효과**: 라우트 정의 호환성 확대, 사용자 학습 비용 절감.

- ✅ 해결 (2025-11-18): 빌더와 매처가 `:name*` zero-or-more 파라미터를 지원하고 충돌/우선순위 규칙 테스트가 추가됨.

#### 2.6.4. 관측성(Observability) 부족

- **문제점**: 캐시 히트/미스, 정적 패스트 히트율, 파라미터 브랜치 히트율 등 계측 훅 없음
- **영향**: 실제 트래픽 패턴 기반 최적화와 회귀 분석 어려움
- **타당성**: 높음 – 측정 훅이 전혀 없어 운영 데이터 확보가 불가함.
- **우선순위**: 중 – 기능보다 운영 효율 관점이지만 대규모 배포 시 중요.
- **적용 시 기대효과**: 병목 구간 식별과 성능 회귀 조기 탐지 가능.

- ✅ 해결 (2025-11-18): `RouterObserverHooks`가 캐시/정적/파라미터/스테이지 훅을 노출하고, 새 통합 테스트(`observability.test.ts`)로 이벤트 플로우를 검증함.

### 2.7. 검증 및 에러 처리 문제

#### 2.7.1. 중복 파라미터명 검증의 제한적 범위

- **문제점**: 같은 경로 내에서만 중복 검증 (`/users/:id/:id`는 차단), 서로 다른 브랜치는 허용
- **예시**: `/users/:id/posts`와 `/posts/:id/comments` - 둘 다 `:id` 사용 가능
- **영향**: 파라미터 객체에서 키 덮어쓰기 또는 의도하지 않은 값 전달 가능
- **타당성**: 중 – 현재 병합 로직이 브랜치 간 충돌을 허용하지만 실제 문제는 설계에 따라 다름.
- **우선순위**: 하 – 같은 이름을 의도적으로 쓰는 경우도 많아 일괄 제한이 어려움.
- **적용 시 기대효과**: 엄격 모드 도입 시 파라미터 충돌 버그를 초기에 발견 가능.

- ✅ 해결 (2025-11-18): `strictParamNames` 옵션이 전역적으로 파라미터 이름 충돌을 감지해 엄격 모드에서 즉시 차단하도록 구현됨.

#### 2.7.2. 와일드카드 라우트 충돌 검사의 비대칭성

- **문제점**: 와일드카드 존재 시 정적/파라미터 추가가 차단되는데, 삭제/수정 API를 제공하지 않는 정책상 동일 프로세스에서 해제를 수행할 수 없음.
- **영향**: 충돌을 해소하려면 새 빌더 인스턴스로 전체 라우터를 재빌드한 뒤, 해당 스냅샷을 포함한 애플리케이션을 다시 기동해야 한다. 즉시 교체 수단이 없으므로 배포 파이프라인과 재시작 자동화가 필수다.
- **타당성**: 높음 – 차단 로직 자체는 필요하지만, 현재는 재빌드 워크플로가 정립되지 않아 운영 부담이 큼.
- **우선순위**: 중 – 라우트 구성이 자주 바뀌는 서비스에서 재빌드 자동화가 없으면 생산성이 크게 떨어짐.
- **적용 시 기대효과**: 재빌드/재배포 파이프라인이 정착되면 명시적인 정책(런타임 수정 금지)과 맞물려 일관된 충돌 관리가 가능하며, 다운타임 없이 롤링 재시작을 계획할 수 있음.

- ✅ 해결 (2025-11-18): 스냅샷 CLI/문서가 재빌드 파이프라인을 제시하여 와일드카드 충돌 시 새 빌드를 배포하는 표준 절차를 마련함.

#### 2.7.3. 메서드별 라우트 중복 등록 시 에러 메시지 불명확

- **문제점**: "Route already exists for method at path" 에러에 메서드명 미포함
- **영향**: 디버깅 시 정확한 충돌 지점 파악 어려움
- **타당성**: 높음 – 실제 에러 메시지 출력에 메서드 정보가 없음.
- **우선순위**: 하 – 심각한 버그는 아니지만 개발자 경험 저하.
- **적용 시 기대효과**: 충돌 원인 파악 속도가 빨라져 개발 효율 개선.

- ✅ 해결 (2025-11-18): 중복 라우트 예외 메시지가 `Route already exists for GET ...` 식으로 메서드명을 포함하도록 업데이트됨.

#### 2.7.4. 옵셔널 파라미터의 빈 값 처리 불명확

- **문제점**: `:id?` 같은 옵셔널 파라미터가 세그먼트 없을 때 파라미터 객체에 키 자체 미포함
- **영향**: `params.id === undefined` vs `!('id' in params)` 구분 필요로 혼란 가능
- **타당성**: 중 – 현재 동작과 문서가 일치하나 사용자 기대와 다를 수 있음.
- **우선순위**: 하 – 문서화로도 해결 가능해 즉시성 낮음.
- **적용 시 기대효과**: 정책 명확화 시 API 일관성 강화.

- ✅ 해결 (2025-11-18): `optionalParamBehavior` 옵션으로 `omit`/`setUndefined`/`setEmptyString` 모드를 제공하고 README에 동작을 명시함.

### 2.8. 상태 관리 문제

#### 2.8.1. 동적 라우트 플래그의 빌드 타임 재계산 필요

- **문제점**: `hasDynamicRoutes`, `hasWildcardRoutes` 등 플래그가 런타임 중 한번 `true`가 되면 재빌드 전까지 `false`로 돌아가지 않음.
- **영향**: 라우터가 수정 불가 정책을 고수하는 만큼, 새 빌드가 생성될 때마다 정확한 상태를 다시 계산하지 않으면 최적화 조건이 과도하게 활성화된 채 고정될 수 있음.
- **타당성**: 중 – 현재도 플래그가 단방향으로만 변해 장기 실행 시 정보가 부풀려짐.
- **우선순위**: 중 – 빌드 파이프라인 상에서 재계산 훅을 넣는 것이 상대적으로 수월함.
- **적용 시 기대효과**: 스냅샷마다 정확한 플래그를 갖게 되어 빌드-불변 최적화의 신뢰도가 높아짐.

- ✅ 해결 (2025-11-18): `recalculateRouteFlags` 스테이지가 빌드 파이프라인에 추가되어 각 스냅샷 생성 시 플래그를 재계산함.

---

## 3. 개선 제안

### 3.1. 캐시 관련 개선

#### 3.1.1. 버전 관리 기반 무효화

- **개선안**:
  - 라우터 내부에 전역 `version` 또는 `epoch` 카운터 도입
  - 라우트 추가/삭제 시 `version` 1씩 증가
  - 캐시 항목 저장 시 현재 `version` 함께 저장
  - 캐시 조회 시 저장된 `version`과 현재 `version` 비교로 stale 처리
- **장점**: 복잡한 접두사 분석 없이 `O(1)` 시간 복잡도로 캐시 무효화 판단, 버그 가능성 감소
- **단점**: 관련 없는 라우트 추가 시에도 점진적 무효화 (전체 삭제보다는 효율적)
- **타당성**: 높음 – 흔히 쓰이는 전략이며 현재 구조에도 쉽게 적용 가능.
- **우선순위**: 상 – 캐시 무효화 불안정성 해결의 핵심.
- **적용 시 기대효과**: 예측 가능한 캐시 수명과 높은 히트율 유지.

#### 3.1.2. 완전한 LRU 구현

- **개선안**: 캐시 조회 시에도 `delete` + `set` 수행 또는 `lru-cache` 같은 전문 라이브러리 사용
- **기대효과**: 실질적인 LRU 효과 달성
- **타당성**: 중 – 단순 구현으로 충분할 수 있으나 라이브러리 교체가 부담이 적음.
- **우선순위**: 중 – 캐시 효율이 낮은 서비스에서 우선 고려.
- **적용 시 기대효과**: 핫 경로 유지로 캐시 스래싱 감소.

#### 3.1.3. 캐시 키 포맷 강화

- **개선안**: 구분자를 null 문자(`\0`)나 확실히 구별되는 패턴으로 변경
- **기대효과**: 이론적 충돌 가능성 제거
- **타당성**: 중 – 현재도 안전하지만 포맷 강화는 저비용.
- **우선순위**: 하 – 실질적 충돌 사례가 없어 긴급도 낮음.
- **적용 시 기대효과**: 향후 메서드 확장 시에도 안정적인 캐시 키 유지.

#### 3.1.4. CacheIndex 메모리 누수 수정

- **개선안**: `noKeys && node.children.size === 0`일 때 `true` 반환하여 부모가 노드 삭제하도록 수정
- **기대효과**: 장기 실행 시 메모리 누수 방지
- **타당성**: 높음 – 명확한 로직 버그를 바로 잡는 변경.
- **우선순위**: 상 – 메모리 누수는 장기 운영에서 치명적.
- **적용 시 기대효과**: 캐시 인덱스 크기 안정화와 GC 부담 완화.

### 3.2. 보안 관련 개선

#### 3.2.1. '%2F' 디코딩 정책 옵션화

- **개선안**: `decodeParams` 확장하여 `strict` 모드(슬래시/역슬래시 미디코딩)와 `loose` 모드(현행) 선택 가능
- **추가 옵션**: `preserveEncodedSlashes` 모드 제공하여 `%2F`, `%5C` 디코딩 방지
- **기대효과**: 보안/서명된 URL 시나리오에서 원본 보존 보장
- **타당성**: 높음 – 옵션화는 구현 난이도가 낮고 직접적인 보안 요구를 충족함.
- **우선순위**: 상 – 현재 취약점 완화를 위한 빠른 대안.
- **적용 시 기대효과**: 다양한 서비스 보안 정책을 수용하면서 호환성 확보.

#### 3.2.2. 경로 순회 방어 강화

- **개선안**: 정규화 전에 퍼센트 인코딩된 dot 패턴(`%2e`) 사전 검사 또는 디코딩 후 추가 검증 단계 추가
- **기대효과**: 경로 순회 공격 완벽 차단
- **타당성**: 중 – 기존 `blockTraversal`과 조합 시 효과적이나, 이중 디코딩 주의 필요.
- **우선순위**: 중 – 특정 보안 요구가 있는 서비스에서 우선시.
- **적용 시 기대효과**: 경로 기반 접근 제어 신뢰도 향상.

### 3.3. 정규식 관련 개선

#### 3.3.1. 타임아웃 처리 일관화

- **개선안**: `regexSafety.mode=warn` 시 타임아웃을 예외 대신 해당 브랜치 매칭 실패로 처리하고 경고 로그만 남김 (블랙리스트 캐시도 고려)
- **기대효과**: 부분적 성능 저하가 전체 요청 실패로 번지는 것 방지
- **타당성**: 높음 – 현재 warn 모드가 무의미하므로 교정 필요성이 명확함.
- **우선순위**: 상 – 운영 중 false alarm으로 전체 요청이 실패하는 현상을 막음.
- **적용 시 기대효과**: 규칙적 제한을 유지하면서도 서비스 가용성 확보.

#### 3.3.2. 안전성 검사 강화

- **개선안**: `safe-regex2`, `recheck` 같은 전문 라이브러리 통합, NFA 기반 휴리스틱 보강, 샌드박스 실행 한계 테스트 추가
- **기대효과**: 과탐지/과소탐지 축소, 보안 신뢰도 향상
- **참고**: 실제 실행 타임아웃이 이미 1차 방어선으로 구현됨
- **타당성**: 중 – 외부 라이브러리 의존이 늘지만 효과 검증 사례가 많음.
- **우선순위**: 중 – 현재 휴리스틱 한계를 보완해 품질을 높이는 장기 과제.
- **적용 시 기대효과**: 위험 패턴을 조기에 차단하고 허용 패턴을 더 많이 통과시킬 수 있음.

#### 3.3.3. 앵커링 정책 명확화

- **개선안**: 정규식 파싱 시 기존 앵커 제거 또는 사용자에게 앵커 없이 패턴만 제공하도록 문서화
- **기대효과**: 이중 앵커로 인한 매칭 실패 방지
- **타당성**: 높음 – 단순 문서화 또는 전처리로 해결 가능.
- **우선순위**: 중 – 사용자 경험 개선에 직접적.
- **적용 시 기대효과**: 라우트 정의 오류 감소와 지원 요청 감소.

### 3.4. 성능 관련 개선

#### 3.4.1. 정적 패스트 경량 정규화 도입

- **개선안**: 패스트 경로에서 저비용 정규화 (연속 슬래시 병합, 점 세그먼트 제거, 트레일링 슬래시 처리) 수행
- **기대효과**: 정적 히트율 상승, 평균 매칭 지연 감소
- **타당성**: 중 – 정규화 비용과 이득을 균형 있게 검토해야 함.
- **우선순위**: 중 – 트래픽 패턴에 따라 가치가 갈림.
- **적용 시 기대효과**: 흔한 비정규화 요청을 정적 라우트로 흡수해 CPU 절약.

#### 3.4.2. 대소문자 처리 최적화

- **개선안**: 정적 Fast 경로에 원본 대소문자 버전도 함께 저장하여 변환 없이 직접 조회
- **기대효과**: 불필요한 `toLowerCase()` 호출 제거
- **타당성**: 낮음 – 현재도 변환 최소화 로직이 있어 잔여 이득이 작음.
- **우선순위**: 하 – 다른 성능 이슈 해결 후 검토.
- **적용 시 기대효과**: 미세하지만 고빈도 요청에서 CPU 수요 감소.

#### 3.4.3. 파라미터 우선순위 정렬 고도화

- **개선안**:
  - 정기적인 또는 확률적 정렬: 임계값만이 아닌 일정 수 요청마다 또는 확률적으로 정렬 수행
  - (선택적) 통계 데이터 영속화: `paramHitCount` 같은 라우팅 통계를 경량 파일이나 인메모리 DB에 저장하고 재시작 시 로드
- **기대효과**: 더 빠른 최적 순서 도달, "웜업" 상태에서 시작
- **타당성**: 중 – 히트 카운트 기반 재정렬은 이미 존재하므로 보완이 자연스러움.
- **우선순위**: 중 – 트래픽 규모에 따라 효과가 달라 개선 타이밍을 조절할 필요가 있음.
- **적용 시 기대효과**: 재시작 후 곧바로 안정적인 성능 달성.

#### 3.4.4. 와일드카드 suffix 계산 최적화

- **개선안**: `DynamicMatcher` 생성 시점에 suffix 소스 미리 계산하여 생성자 파라미터로 전달
- **참고**: `config.suffixSource`로 이미 구현되어 있으나 활용도 점검 필요
- **타당성**: 높음 – 캐시 전략을 전환하는 단순 변경으로 성능 이득을 기대할 수 있음.
- **우선순위**: 중 – 와일드카드 비중이 높은 서비스일수록 우선.
- **적용 시 기대효과**: 런타임 조립 비용 감소로 tail latency 개선.

### 3.5. 아키텍처 및 유지보수 개선

#### 3.5.1. `match-walker.ts` 코드 가독성 향상

- **개선안**:
  - 주석 및 문서화 강화: 각 `FrameStage` 역할과 상태 전이 과정 상세 주석 추가
  - 로직 분리: 스택 프레임의 각 단계를 별도 private 메서드로 분리 (`processStaticStage`, `processParamsStage` 등)
- **기대효과**: 유지보수성 향상
- **타당성**: 높음 – 문서화/구조화는 확실한 효과가 있음.
- **우선순위**: 중 – 신규 기여자 유입 시 체감도가 큼.
- **적용 시 기대효과**: 코드 리뷰 시간 단축과 버그 탐지 용이성 향상.

#### 3.5.2. 정적 압축 타이밍 개선

- **개선안**: `add`/`addAll` 완료 시점에 자동 압축 수행 또는 내부 API 호출 시 `ensureCompressed` 일관 적용
- **기대효과**: 일관된 트리 구조, 디버깅/테스트 편의성 향상
- **타당성**: 높음 – 훅 추가만으로 보장 가능.
- **우선순위**: 중 – 운영 영향은 제한적이나 개발 경험 향상.
- **적용 시 기대효과**: 트리 상태가 예측 가능해 리그레션 테스트가 쉬워짐.
- **상태**: 해결됨 (2025-11-16, PLAN 1.2) – `compressStaticSubtree`가 빌드 파이프라인 첫 단계로만 실행되고 `match()` 경로의 `ensureCompressed`/`requestCompression` 훅을 제거했다. 벤치 러너가 스테이지 로그를 정제한 JSON을 생성하도록 보완하여 `router-bench-2025-11-16T12-27-06-205Z` 결과로 회귀 없는 것을 확인했다.

#### 3.5.3. 압축 전략의 메서드 고려

- **개선안**: 메서드별로 독립적인 트리 구성 또는 압축 로직에서 메서드를 고려한 병합 전략 적용
- **기대효과**: 메서드 혼재 환경에서 압축 효율 향상
- **타당성**: 중 – 구조를 크게 바꿔야 하지만 문제를 직접 겨냥함.
- **우선순위**: 중 – 대규모 API에서만 체감되므로 단계적으로 추진.
- **적용 시 기대효과**: 트리 깊이 감소로 메모리와 CPU 모두 절약.

- ✅ 해결 (2025-11-18): 정적 압축이 메서드가 등록된 노드를 분리해 다른 메서드 서브트리를 계속 압축하도록 조정됐고, 혼합 메서드 시나리오를 통합 테스트로 보증함.

### 3.6. API 및 기능 추가

#### 3.6.1. 불변 스냅샷 배포 가이드

- **개선안**: 라우터 스냅샷은 빌드 타임에만 생성·확정하고, Bun 프로세스가 기동될 때 읽기 전용으로 주입되도록 CLI/매니페스트를 제공한다. 런타임 스왑 API를 노출하지 않는 대신, 재배포 절차(예: 컨테이너 교체, 프로세스 재시작)를 자동화할 수 있는 문서/스크립트를 패키지에 포함한다.
- **기대효과**: 운영팀이 “교체 불가” 정책을 명확히 이해하고, 라우터 업데이트를 배포 파이프라인 문제로 취급하게 되어 책임 구분이 선명해진다.
- **타당성**: 높음 – 이미 불변 아키텍처를 전제로 하므로 적용 범위가 사전 정의되어 있다.
- **우선순위**: 중 – 재배포 플로가 정착되지 않으면 정책 오해로 장애가 발생할 수 있음.
- **적용 시 기대효과**: 릴리스 노트와 배포 스크립트가 결합되어, 어떤 서비스도 실수로 런타임 교체를 시도하지 않고 안정적으로 재시작 절차를 밟게 된다.

#### 3.6.2. 메서드 호환성 옵션 추가

- **개선안**: 옵션으로 `headFallbackToGet`, `autoOptions` 제공하여 `HEAD -> GET` 자동 대체와 `OPTIONS` 자동 응답(허용 메서드 노출) 지원
- **기대효과**: API 사용성 향상, 상위 레이어 보일러플레이트 감소
- **타당성**: 중 – 구현은 단순하지만 설계 철학과 맞는지 검토 필요.
- **우선순위**: 중 – 프레임워크 사용 편의성을 크게 높일 수 있음.
- **적용 시 기대효과**: 표준 HTTP 요구사항을 기본 제공하여 개발자 경험 개선.

#### 3.6.3. ':name\*' 지원 추가

- **개선안**: `:name*`를 와일드카드와 구분하여 0개 이상 세그먼트 캡처 지원 (마지막 세그먼트 제한 유지)
- **기대효과**: 라우팅 표현력 향상, 타 프레임워크와의 호환성 강화
- **타당성**: 중 – 파서/매처 영향 범위를 명확히 파악해야 함.
- **우선순위**: 중 – 마이그레이션 비중이 높을수록 우선순위 상승.
- **적용 시 기대효과**: 기존 라우트 정의를 거의 수정 없이 이식 가능.

#### 3.6.4. 관측성 훅 추가

- **개선안**: `onRouteMatch`, `onCacheHit/Miss`, `onStaticFastHit`, `onParamBranchTaken` 등 콜백/카운터를 옵션으로 제공
- **기대효과**: 실제 트래픽 기반 최적화 및 회귀 분석 용이
- **타당성**: 높음 – 훅만 노출하면 되므로 구조 영향이 작음.
- **우선순위**: 중 – 운영 모니터링이 필요한 팀에 즉각적인 가치.
- **적용 시 기대효과**: 성능/품질 지표가 확보되어 튜닝 사이클 단축.

### 3.7. 검증 및 에러 처리 개선

#### 3.7.1. 중복 파라미터명 검증 강화

- **개선안**: 전역적으로 파라미터명 네이밍 컨벤션 가이드 제공 또는 옵션으로 엄격한 중복 검사 모드 제공
- **기대효과**: 의도하지 않은 파라미터 값 전달 방지
- **타당성**: 중 – 실제 충돌 사례를 옵션으로 제어 가능.
- **우선순위**: 하 – 문서화로도 완화 가능.
- **적용 시 기대효과**: 파라미터 네임스페이스 충돌로 인한 버그 감소.

#### 3.7.2. 에러 메시지 개선

- **개선안**: 라우트 중복 등록 시 에러 메시지에 메서드명 포함 (예: `GET already exists at /users/:id`)
- **기대효과**: 디버깅 편의성 향상
- **타당성**: 높음 – 메시지 포맷 변경만으로 큰 이득.
- **우선순위**: 하 – 영향 범위는 제한적이지만 구현은 간단.
- **적용 시 기대효과**: 개발자 오류 해결 시간이 단축됨.

#### 3.7.3. 옵셔널 파라미터 값 처리 정책

- **개선안**: 옵션으로 옵셔널 파라미터에 대해 `undefined` 또는 빈 문자열을 명시적으로 설정하는 모드 제공
- **기대효과**: 사용자 혼란 감소, 명확한 API
- **타당성**: 중 – 구현 난이도는 낮으나 기존 사용자 영향 분석 필요.
- **우선순위**: 하 – 문서 안내로도 해결 가능하나 선택지 제공이 더 친절함.
- **적용 시 기대효과**: params 처리 로직의 분기 감소, 타입 정의 명확화.

### 3.8. 상태 관리 개선

#### 3.8.1. 동적 라우트 플래그 정합성 유지

- **개선안**: `build()` 과정에서 전체 트리를 재스캔하여 `hasDynamicRoutes`, `hasWildcardRoutes` 같은 플래그를 계산하고, 런타임에는 읽기 전용 상수로 유지.
- **기대효과**: 최적화 로직의 정확성 보장
- **타당성**: 중 – 빌드 파이프라인에 재계산 훅만 추가하면 됨.
- **우선순위**: 중 – 상태 정확성이 최적화 결정에 직접 작용.
- **적용 시 기대효과**: 플래그 기반 최적화가 오작동하지 않아 성능 회귀 방지.

### 3.9. 빌드-불변 아키텍처 도입

#### 3.9.1. RouterBuilder/RouterInstance 이원화

- **개선안**: 라우트 추가·검증은 `RouterBuilder`에서만 수행하고, `build()` 호출 시 읽기 전용 `RouterInstance`를 생성하여 런타임에는 매칭 API만 노출.
- **효과**: 삽입/삭제 API가 없더라도 Rust 스타일의 “insert → build → readonly” 흐름을 구현해 런타임 변이를 명확히 차단.
- **타당성**: 높음 – 기존 코드 구조를 크게 훼손하지 않고 책임을 분리할 수 있음.
- **우선순위**: 상 – 빌드 이후 구조가 고정되어야만 가능한 최적화가 많고, 운영 안정성 요구가 큼.
- **적용 시 기대효과**: 배포 시 빌드 오류를 선제적으로 감지하고, 런타임에는 락 없이 고성능 경로 탐색이 가능.

#### 3.9.2. 빌드 타임 최적화 일괄 실행

- **개선안**: `build()` 과정에서 정적 압축, 파라미터 우선순위 재정렬, 와일드카드 suffix 사전 계산, regex 안전성 검증을 순차 파이프라인으로 묶어 실패 시 즉시 롤백.
- **효과**: 실행 중에 지연되던 최적화가 모두 빌드 단계에서 확정되므로 로직 일관성과 성능 모두 확보.
- **타당성**: 높음 – 이미 존재하는 최적화들을 호출 순서만 정리하면 됨.
- **우선순위**: 중 – 현재 문제의 상당수가 “지연 실행/조건부 실행”에서 비롯됨.
- **적용 시 기대효과**: 프로파일링/테스트 환경에서도 운영과 동일한 트리 구조가 보장되어 회귀 분석이 쉬워짐.

#### 3.9.3. 불변 데이터 레이아웃 채택

- **개선안**: 빌드 완료 후 트리·캐시를 `Map`/`Set` 대신 불변 배열+오프셋 구조로 직렬화하고, 개발 모드에서는 `Object.freeze`로 쓰기 시도를 차단.
- **효과**: GC 친화적인 연속 메모리와 JIT 최적화 친화적 접근 패턴 구축.
- **타당성**: 중 – 자료구조 변환이 필요하지만 큰 폭의 성능 향상을 기대할 수 있음.
- **우선순위**: 중 – 대규모 라우트 테이블을 운영하는 서비스에서 체감도가 큼.
- **적용 시 기대효과**: 캐시 친화적 레이아웃 덕분에 매칭 지연과 메모리 사용량이 모두 감소.

### 3.10. 옵션 기반 파이프라인 엔진화

#### 3.10.1. 스테이지 선언과 옵션 매핑

- **개선안**: `Normalize → Decode → TraversalGuard → Compile → Suffix → Cache → Match` 식의 스테이지를 선언형으로 정의하고, 각 스테이지에 `enabled`, `mode` 옵션을 연결.
- **효과**: insert/match/build 전 과정이 동일 파이프라인 정의를 공유해 옵션 조합에 따른 동작 차이가 사라짐.
- **타당성**: 높음 – 기존 전처리·매칭 코드를 스테이지 클래스로 감싸면 구현 가능.
- **우선순위**: 중 – 기능 추가보다도 품질과 이해도를 높이는 기반 작업.
- **적용 시 기대효과**: 서비스별 요구(보안, 성능, 호환성)에 맞춘 설정 프리셋을 빠르게 제공할 수 있음.

#### 3.10.2. 빌드/매칭/캐시 스테이지 토글화

- **개선안**: 빌드 시 실행할 스테이지(압축, 파라미터 통계 저장, 버전 캐시 초기화)와 런타임 스테이지(정적 Fast, 파라미터 브랜치, 와일드카드)를 명시적으로 구분하고, 옵션에 따라 일부 스테이지만 활성화.
- **효과**: 필요 없는 검사를 제거하고 필수 스테이지만 남겨 CPU 사용을 줄임.
- **타당성**: 중 – 스테이지 구분이 명확해지면 테스트/프로파일링도 쉬워짐.
- **우선순위**: 중 – 고성능/저메모리 프로파일을 각각 만들 수 있음.
- **적용 시 기대효과**: SaaS 테넌트별로 서로 다른 라우터 프로파일을 제공해 리소스 효율 극대화.

#### 3.10.3. 관측·튜닝 훅 내장

- **개선안**: 각 스테이지에 `onStageStart`, `onStageEnd` 훅과 지연 측정을 넣고, 옵션으로 메트릭 수집기나 트레이서를 주입.
- **효과**: 파이프라인 단위로 히트율/지연을 실시간 확인 가능해 운영 중에도 안전하게 파라미터를 조정.
- **타당성**: 높음 – 훅 노출만으로 구현 가능하며 기존 관측성 부족 문제를 직접 해결.
- **우선순위**: 중 – 대규모 배포나 다중 테넌트 환경에서 가시성이 필수.
- **적용 시 기대효과**: 성능 회귀를 조기에 탐지하고 A/B 실험을 빠르게 반복.

### 3.11. 고급 최적화 및 운영 전략

#### 3.11.2. 정적 경로 SIMD/비트셋 최적화

- **개선안**: 빌드 단계에서 정적 경로를 길이별 배열과 비트셋으로 압축하고, 매칭 시 SIMD 문자열 비교를 활용.
- **효과**: readonly 데이터 레이아웃과 결합해 L1 캐시 히트율 및 비교 속도를 높임.
- **타당성**: 중 – 런타임 엔진(V8) 특성을 고려한 실험이 필요하나 원리는 명확.
- **우선순위**: 중 – 극단적 고트래픽 환경에서 우선 적용.
- **적용 시 기대효과**: 정적 히트 경로의 지연이 마이크로초 단위로 단축.
