# Bunner Framework Requirements & Roadmap

이 문서는 Bunner 프레임워크가 상용 수준(Production-ready)의 안정성과 개발자 경험(DX)을 갖추기 위해 필요한 핵심 요구사항을 기술합니다. **"런타임 오버헤드 없는 고성능"**이라는 핵심 철학을 유지하면서 DX를 극대화하는 것을 목표로 합니다.

## 1. CLI Watcher의 정교화 (DX 보강)

NestJS는 `nest start --watch`를 통해 코드를 고치면 즉시 반영됩니다. Bunner는 CLI가 메타데이터를 미리 생성해야 하므로 이 과정이 더욱 정교하게 자동화되어야 합니다.

- **목표**: `bunner start --watch` 실행 시 변경된 파일과 영향을 받는 의존성만 즉시 다시 파싱하여 메타데이터를 갱신합니다.
- **구현 상세**:
  - **증분 빌드(Incremental Build)**: `packages/cli`에 `Bun.watch`를 활용하여 파일 변경 이벤트를 감지합니다.
  - **의존성 그래프(Dependency Graph)**: 단순히 수정된 파일만 다시 파싱하는 것을 넘어, 해당 파일을 의존하고 있는 상위 모듈까지 추적하여 필요한 부분만 Invalidation 하는 로직을 구현합니다.
  - **캐싱(Caching)**: 파일 해시(Hash) 비교 등을 통해 변경사항이 없는 파일의 재파싱을 방지하여 빌드 속도를 최적화합니다.

## 2. JIT 생성 코드의 디버깅 편의성 (안정성 보강)

`new Function()`으로 생성된 코드는 에러 발생 시 **스택 트레이스(Stack Trace)**를 읽기가 매우 어렵습니다. 이는 프레임워크 유지보수 및 사용자 디버깅의 큰 진입 장벽입니다.

- **목표**: 런타임에 동적으로 생성된 코드도 실제 소스 코드처럼 디버깅 가능하게 합니다.
- **구현 상세**:
  - **Source URL 매핑**: 생성되는 함수 문자열 맨 뒤에 `//# sourceURL=bunner://jit/UserController_transform.js`와 같은 가상 경로를 추가합니다. 이를 통해 브라우저 devtools나 IDE에서 식별 가능한 파일로 표시됩니다.
  - **Pretty Printing**: 생성된 코드가 한 줄로 뭉쳐지지 않도록 포맷팅(들여쓰기, 줄바꿈)을 적용하여 가독성을 확보합니다.
  - **Source Map (Optional)**: 장기적으로는 원본 소스 코드와의 매핑을 위한 가벼운 소스 맵 생성도 고려합니다.

## 3. 순환 참조(Circular Dependency)의 정적 탐지 및 해결 가이드

단순히 순환 참조를 **감지**하는 것을 넘어, 개발자에게 **구체적인 해결책**을 제시해야 합니다.

- **목표**: 런타임 이전에 순환 참조를 탐지하고, `ForwardRef` 적용 위치를 정확히 안내하여 친절한 DX를 제공합니다.
- **구현 상세**:
  - **사이클 탐지 및 시각화**: 의존성 그래프에서 `A -> B -> C -> A`와 같은 순환 경로를 찾아 시각적으로 에러 메시지에 표시합니다.
  - **Actionable Guide 제공**: 그래프 분석을 통해 사이클을 끊기 가장 적절한 위치(생성자 등)를 식별하고, **"AController의 생성자에 @Inject(forwardRef(() => BService))를 추가하세요"**와 같은 구체적인 코드 수정 가이드를 출력합니다.

## 4. 복잡한 타입 및 제네릭 완벽 대응 (기술적 심화)

단순한 타입뿐만 아니라 TypeScript의 복잡한 타입 시스템(Generic, Utility Types 등)을 완벽하게 지원해야 합니다. MVP 단계는 없으며, 처음부터 엄격한 기준을 적용합니다.

- **목표**: `emitDecoratorMetadata` 없이도 복잡한 타입 구조를 100% 분석하여 정확한 런타임 유효성 검사 코드를 생성합니다.
- **구현 상세**:
  - **Deep Recursive Analysis**: `oxc-parser`를 사용하여 제네릭 인자, 중첩된 배열, `Partial`, `Pick` 등의 유틸리티 타입까지 재귀적으로 완벽하게 분석합니다.
  - **외부 패키지 타입 지원**: `node_modules`의 `.d.ts` 파일까지 추적하여 외부 라이브러리 타입도 놓치지 않고 분석합니다.

## 5. Bun 네이티브 최적화 (현재 구현체 한정)

`http-server`의 응답 처리 등 아직 미완성된 부분은 제외하고, **현재 구현된 코드(CLI, Core)** 내에서 Bun 최적화를 진행합니다.

- **목표**: 현재 작성된 코드 베이스에서 Node.js API를 Bun Native API로 교체하여 성능을 극대화합니다.
- **구현 상세**:
  - **File I/O 최적화**: CLI의 스캐너나 메타데이터 생성기에서 사용하는 `fs.readFileSync`, `fs.writeFileSync` 등을 `Bun.file()`, `Bun.write()`로 전면 교체합니다.
  - **Module Loading**: 메타데이터 로더 등에서 모듈을 읽어오는 과정의 비효율을 제거합니다.
  - _Note: HTTP Response(Zero-copy) 관련 최적화는 http-server 모듈 완성도 제고 후 진행합니다._

## 6. 프레임워크 특화 UX 및 에러 핸들링

컴파일러(TSC/Bun)가 잡아주는 문법적 오류가 아닌, **프레임워크 논리 오류**와 **JIT 디버깅**에 집중합니다.

- **목표**: 사용자가 겪을 수 있는 '도메인 특화 에러'에 대해 친절하고 명확한 가이드를 제공합니다.
- **구현 상세**:
  - **JIT 디버깅 지원**: 동적 생성 코드 에러 시, 원본 소스의 어느 부분이 문제인지 역추적 가능한 정보를 제공합니다.
  - **논리적 오류 가이드**: 데코레이터 누락, 잘못된 의존성 주입 등 컴파일러는 통과하지만 프레임워크 실행 시 문제가 되는 케이스를 명확한 에러 메시지로 안내합니다.
  - **Security**: JIT 코드 생성 시 사용자 입력값에 대한 철저한 이스케이프 처리로 Injection을 방지합니다.
